<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guía de Estudio c# y .NET</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {font-family:'Inter','Segoe UI',sans-serif;background:#f9fafc;margin:0;padding:20px;color:#333;}
        h1 {text-align:center;color:#2c3e50;margin-bottom:30px;}
        .chapter {background:white;box-shadow:0 3px 10px rgba(0,0,0,0.06);border-radius:10px;margin:20px auto;max-width:900px;overflow:hidden;}
        .chapter-header {
            margin:0;
            padding:16px 24px;
            background:#e8eef5;
            color:#2c3e50;
            cursor:pointer;
            font-size:1.3em;
            font-weight:600;
            transition:background 0.3s;
        }
        .chapter-header:hover {background:#dbe7f3;}
        .chapter-content {
            display:none;
            padding:20px 40px;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn {from {opacity:0;} to {opacity:1;}}
        .close-btn {
            display:block;
            margin:10px auto 20px;
            padding:8px 14px;
            background:#e74c3c;
            color:white;
            border:none;
            border-radius:5px;
            cursor:pointer;
            font-weight:bold;
            font-size:0.85em;
            transition:background 0.3s;
        }
        .close-btn:hover{background:#c0392b;}
        
        /* MODIFICACIÓN 2: Fondo gris claro para bloques de código */
        pre {
            background:#f3f3f3; /* Gris muy claro */
            color:#333; /* Color de texto oscuro para buen contraste */
            border-radius:8px;
            padding:1.2em;
            overflow-x:auto;
            font-family:'Source Code Pro',monospace;
            font-size:0.95em;
            border: 1px solid #ddd;
        }
        
        /* MODIFICACIÓN 1: Color más oscuro para código inline */
        code { 
            background: #eee; /* Fondo claro para destacar */
            color: #1e1e1e; /* Color de texto muy oscuro */
            padding: 2px 4px;
            border-radius: 4px;
            font-family:'Source Code Pro',monospace;
            font-size:0.95em;
        }
        
        /* Ajuste de colores de sintaxis para fondo claro */
        .language-csharp .kw { color:#0000ff; } /* Palabras clave: Azul intenso */
        .language-csharp .str { color:#a31515; } /* Strings: Rojo oscuro */
        .language-csharp .comm { color:#008000; font-style:italic; } /* Comentarios: Verde */
        .language-csharp .type { color:#2b91af; } /* Tipos: Cian oscuro */
        .language-csharp .prop { color:#000000; } /* Propiedades/Variables: Negro */
        .language-csharp .meth { color:#795e26; } /* Métodos: Marrón oscuro */
        .language-csharp .lit { color:#17505a; } /* Literales (números, booleanos): Teal oscuro */
        .language-csharp .sym { color:#993399; } /* Símbolos/Operadores: Púrpura */
    </style>
</head>
<body>
    <h1>Guía de Estudio c# y .NET — LEVEL 20–32</h1>
    <div id="chapters">

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 20: PROPERTIES</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li>Properties give you field-like access while still protecting data with methods: <code><span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span> { <span class="kw">get</span> =&gt; width; <span class="kw">set</span> =&gt; width = <span class="kw">value</span>; }</code>. To use a property: <code>rectangle.<span class="prop">Width</span>= 3;</code></li>
                    <li>Auto-properties are for when no extra logic is needed: <code><span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span> { <span class="kw">get</span>; <span class="kw">set</span>; }</code></li>
                    <li>Properties can be read-only, only settable in a constructor: <code><span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span> { <span class="kw">get</span>; }</code></li>
                    <li>Fields can also be read-only: <code><span class="kw">private</span> <span class="kw">readonly</span> <span class="type">float</span> _width = 3;</code></li>
                    <li>With properties, objects can be initialized using object initializer syntax: <code><span class="kw">new</span> <span class="type">Rectangle</span>() { <span class="prop">Width</span> = 2, <span class="prop">Height</span> = 3 }</code>.</li>
                    <li>An <code>init</code> accessor is like a setter but only usable in object initializer syntax. <code><span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span>{ <span class="kw">get</span>; <span class="kw">init</span>; }</code></li>
                </ul>

                <p>Thus, the first stab at a property-based <code>Rectangle</code> class might look like this:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Rectangle</span>
{
                <span class="kw">private</span> <span class="type">float</span> _width;
                <span class="kw">private</span> <span class="type">float</span> _height;
                <span class="kw">public</span> <span class="type">Rectangle</span>(<span class="type">float</span> width, <span class="type">float</span> height)
    {
        _width = width;
        _height = height;
    }

                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span>
    {
                <span class="kw">get</span> =&gt; _width;
                <span class="kw">set</span> =&gt; _width = <span class="kw">value</span>;
    }

                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Height</span>
    {
                <span class="kw">get</span> =&gt; _height;
                <span class="kw">set</span> =&gt; _height = <span class="kw">value</span>;
    }

                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Area</span> =&gt; _width * _height;
}</code></pre>

                <p>A property’s getter and setter do not need to have the same accessibility level.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span>
{
                <span class="kw">get</span> =&gt; _width;
                <span class="kw">private</span> <span class="kw">set</span> =&gt; _width = <span class="kw">value</span>;
}</code></pre>

                <h3>AUTO-IMPLEMENTED PROPERTIES</h3>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Player</span>
{
                <span class="kw">public</span> <span class="type">string</span> <span class="prop">Name</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre>
                <p>...initializing the backing field to a specific starting value:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">string</span> <span class="prop">Name</span> { <span class="kw">get</span>; <span class="kw">set</span>; } = <span class="str">"Player"</span>;</code></pre>
                <p>A version of the <code>Rectangle</code> class that uses auto-properties might look like this:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Rectangle</span> <span class="comm">// Note how short this code got with auto-properties.</span>
{
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Width</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Height</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Area</span> =&gt; <span class="prop">Width</span> * <span class="prop">Height</span>;
                <span class="kw">public</span> <span class="type">Rectangle</span>(<span class="type">float</span> width, <span class="type">float</span> height)
    {
                <span class="prop">Width</span> = width;
                <span class="prop">Height</span> = height;
    }
}</code></pre>

                <h3>IMMUTABLE FIELDS AND PROPERTIES</h3>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Player</span>
{
                <span class="kw">public</span> <span class="type">string</span> <span class="prop">Name</span> { <span class="kw">get</span>; } = <span class="str">"Player 1"</span>;
                <span class="kw">public</span> <span class="type">Player</span>(<span class="type">string</span> name)
    {
                <span class="prop">Name</span> = name;
    }
}</code></pre>
                <p>If you have a field that you don’t want to change after construction, you can apply the <code>readonly</code> keyword to it as a modifier.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Player</span>
{
                <span class="kw">private</span> <span class="kw">readonly</span> <span class="type">string</span> _name;
                <span class="kw">public</span> <span class="type">Player</span>(<span class="type">string</span> name)
    {
        _name = name;
    }
}</code></pre>
                <p>When all of a class’s properties and fields are immutable (get-only auto-properties and <code>readonly</code> fields), the entire object is immutable.</p>

                <h3>OBJECT INITIALIZER SYNTAX AND INIT PROPERTIES</h3>
                <p>Let’s say we have this <code>Circle</code> class:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Circle</span>
{
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">X</span> { <span class="kw">get</span>; <span class="kw">set</span>; } = <span class="lit">0</span>; <span class="comm">// The x-coordinate of the circle's center.</span>
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Y</span> { <span class="kw">get</span>; <span class="kw">set</span>; } = <span class="lit">0</span>; <span class="comm">// The y-coordinate of the circle's center.</span>
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Radius</span> { <span class="kw">get</span>; <span class="kw">set</span>; } = <span class="lit">0</span>;
}</code></pre>
                <p>...we could make a new circle and set its properties like this:</p>
<pre><code class="language-csharp"><span class="type">Circle</span> circle = <span class="kw">new</span> <span class="type">Circle</span>();
circle.<span class="prop">Radius</span> = <span class="lit">3</span>;
circle.<span class="prop">X</span> = -<span class="lit">4</span>;</code></pre>
                <p>C# provides a simple syntax for setting properties right as the object is created called <b>object initializer syntax</b>:</p>
<pre><code class="language-csharp"><span class="type">Circle</span> circle = <span class="kw">new</span> <span class="type">Circle</span>() { <span class="prop">Radius</span> = <span class="lit">3</span>, <span class="prop">X</span> = -<span class="lit">4</span> };</code></pre>
                <p>If the constructor is parameterless, you can even leave out the parentheses:</p>
<pre><code class="language-csharp"><span class="type">Circle</span> circle = <span class="kw">new</span> <span class="type">Circle</span> { <span class="prop">Radius</span> = <span class="lit">3</span>, <span class="prop">X</span> = -<span class="lit">4</span> };</code></pre>
                <p>The middle ground is an <code>init</code> accessor. This is a setter that can be used in limited circumstances, including with an inline initializer (the 0’s below) and in the constructor, but also in object initializer syntax.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Circle</span>
{
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">X</span> { <span class="kw">get</span>; <span class="kw">init</span>; } = <span class="lit">0</span>;
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Y</span> { <span class="kw">get</span>; <span class="kw">init</span>; } = <span class="lit">0</span>;
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Radius</span> { <span class="kw">get</span>; <span class="kw">init</span>; } = <span class="lit">0</span>;
}</code></pre>
<pre><code class="language-csharp"><span class="type">Circle</span> circle = <span class="kw">new</span> <span class="type">Circle</span> { <span class="prop">X</span> = <span class="lit">1</span>, <span class="prop">Y</span> = <span class="lit">4</span>, <span class="prop">Radius</span> = <span class="lit">3</span> };
<span class="comm">// This would not compile if it were not a comment:</span>
<span class="comm">// circle.X = 2;</span></code></pre>

                <hr>

                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 21: STATIC</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li>Static things are owned by the type rather than a single instance (shared across all instances).</li>
                    <li>Fields, methods, and constructors can all be static.</li>
                    <li>If a class is marked <code>static</code>, it can only contain static members (<code>Console</code>, <code>Convert</code>, <code>Math</code>).</li>
                </ul>

                <h3>STATIC MEMBERS</h3>

                <h4>Static Fields</h4>
                <p>By applying the <code>static</code> keyword to a field, you create a static field or static variable.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Score</span>
{
                <span class="kw">private</span> <span class="kw">static</span> <span class="kw">readonly</span> <span class="type">int</span> <span class="prop">PointThreshold</span> = <span class="lit">1000</span>;
                <span class="kw">private</span> <span class="kw">static</span> <span class="kw">readonly</span> <span class="type">int</span> <span class="prop">LevelThreshold</span> = <span class="lit">4</span>;
                <span class="comm">// ...</span>
}</code></pre>
                <p>...we saw that C# programmers usually name fields with <code>_lowerCamelCase</code>, but if they are static, they tend to be <code>UpperCamelCase</code> instead.</p>
                <p>These two fields are <code>private</code> and <code>readonly</code>, but we can use all the same modifiers on a static field as a normal field.</p>
                <p>Static fields are used within the class in the same way that you would use any other field:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">bool</span> <span class="meth">IsWorthyOfTheHighScoreTable</span>()
{
                <span class="kw">if</span> (<span class="prop">Points</span> < <span class="prop">PointThreshold</span>) <span class="kw">return</span> <span class="lit">false</span>;
                <span class="kw">if</span> (<span class="prop">Level</span> < <span class="prop">LevelThreshold</span>) <span class="kw">return</span> <span class="lit">false</span>;
                <span class="kw">return</span> <span class="lit">true</span>;
}</code></pre>
                <p>If a static field is <code>public</code>, it can be used outside the class through the class name (<code>Score.PointThreshold</code>, for example).</p>

                <h4>Global State</h4>
                <p>It is the combination that is dangerous. Making the field <code>private</code> instead of <code>public</code> limits access to just the class, which is easier to manage. Making the field <code>readonly</code> ensures it can’t change over time, preventing one part of the code from interfering with other parts. If it is not <code>static</code>, only parts of the program that have a reference to the object will be able to do anything with it. Just be cautious any time you make a <code>public static</code> field.</p>

                <h4>Static Properties</h4>
                <p>These can use static fields as their backing fields, or you can make them auto-properties.</p>
                <p>We use static properties on the <code>Console</code> class. <code>Console.ForegroundColor</code> and <code>Console.Title</code> are examples.</p>

                <h4>Static Methods</h4>
                <p>Static methods are most often used for utility or helper methods that isn’t tied directly to a single instance.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">static</span> <span class="type">int</span> <span class="meth">CountForPlayer</span>(<span class="type">string</span> playerName, <span class="type">Score</span>[] scores)
{
                <span class="type">int</span> count = <span class="lit">0</span>;
                <span class="kw">foreach</span> (<span class="type">Score</span> score <span class="kw">in</span> scores)
                <span class="kw">if</span> (score.<span class="prop">Name</span> == playerName) count++;
                <span class="kw">return</span> count;
}</code></pre>
                <p>Another common use of static methods is a <b>factory method</b>, which creates new instances for the outside world as an alternative to calling a constructor.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">static</span> <span class="type">Rectangle</span> <span class="meth">CreateSquare</span>(<span class="type">float</span> size) =&gt; <span class="kw">new</span> <span class="type">Rectangle</span>(size, size);</code></pre>
<pre><code class="language-csharp"><span class="type">Rectangle</span> rectangle = <span class="type">Rectangle</span>.<span class="meth">CreateSquare</span>(<span class="lit">2</span>);</code></pre>
                <p>But it should look familiar; this is how we’ve been calling things like <code>Console.WriteLine</code> and <code>Convert.ToInt32</code>, which are also static methods.</p>

                <h4>Static Constructors</h4>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Score</span>
{
                <span class="kw">public</span> <span class="kw">static</span> <span class="kw">readonly</span> <span class="type">int</span> <span class="prop">PointThreshold</span>;
                <span class="kw">public</span> <span class="kw">static</span> <span class="kw">readonly</span> <span class="type">int</span> <span class="prop">LevelThreshold</span>;
                <span class="kw">static</span> <span class="type">Score</span>()
    {
                <span class="prop">PointThreshold</span> = <span class="lit">1000</span>;
                <span class="prop">LevelThreshold</span> = <span class="lit">4</span>;
    }
}</code></pre>
                <p>A static constructor cannot have parameters, nor can you call it directly. Instead, it runs automatically the first time you use the class. Because of this, you cannot place an accessibility modifier like <code>public</code> or <code>private</code> on it.</p>

                <h3>STATIC CLASSES</h3>
                <p>Some classes are nothing more than a collection of related utility methods, fields, or properties. <code>Console</code>, <code>Convert</code>, and <code>Math</code> are all examples of this.</p>
                <p>In these cases, you may want to forbid creating instances of the class, which is done by marking it with the <code>static</code> keyword:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> <span class="type">Utilities</span>
{
                <span class="kw">public</span> <span class="kw">static</span> <span class="type">int</span> <span class="meth">Helper1</span>() =&gt; <span class="lit">4</span>;
                <span class="kw">public</span> <span class="kw">static</span> <span class="type">double</span> <span class="prop">HelperProperty</span> =&gt; <span class="lit">4.0</span>;
                <span class="kw">public</span> <span class="kw">static</span> <span class="type">int</span> <span class="meth">AddNumbers</span>(<span class="type">int</span> a, <span class="type">int</span> b) =&gt; a + b;
}</code></pre>

                <hr>

                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 22: NULL REFERENCES</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li>Reference types may contain a reference to nothing: <code>null</code>, representing a lack of an object.</li>
                    <li>Carefully consider whether <code>null</code> makes sense as an option for a variable and program accordingly.</li>
                    <li>Check for <code>null</code> with <code>x == null</code>, the null conditional operators <code>x?.DoStuff()</code> and <code>x?[3]</code>, and use <code>??</code> to allow <code>null</code> values to fall back to some other default: <code>x ?? "empty"</code>.</li>
                </ul>

                <p>Reference type variables like <code>string</code>, arrays, and classes don’t store their data directly in the variable. The variable holds a reference and the data lives on the heap somewhere. Most of the time, these references point to a specific object, but in some cases, the reference is a special one indicating the absence of a value. This special reference is called a <code>null reference</code>.</p>

                <h3>NULL OR NOT?</h3>
                <p>For reference-typed variables, stop and think if <code>null</code> should be an option.</p>
                <p>A <code>?</code> means that it may legitimately contain a <code>null</code> value.</p>
<pre><code class="language-csharp"><span class="type">string</span>? name = <span class="type">Console</span>.<span class="meth">ReadLine</span>(); <span class="comm">// Can return null!</span></code></pre>
                <p>Without the <code>?</code>, as we’ve done until now, we show that <code>null</code> is not an option.</p>
                <p>We could (and should!) do a similar thing for usages of our <code>Score</code> and <code>Rectangle</code> classes.</p>

                <h3>CHECKING FOR NULL</h3>
                <p>The easiest way is to compare a reference against the <code>null</code> literal:</p>
<pre><code class="language-csharp"><span class="type">string</span>? name = <span class="type">Console</span>.<span class="meth">ReadLine</span>();
<span class="kw">if</span> (name != <span class="lit">null</span>)
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"The name is not null."</span>);</code></pre>

                <h4>Null-Conditional Operators: <code>?.</code> and <code>?[]</code></h4>
<pre><code class="language-csharp"><span class="kw">private</span> <span class="type">string</span>? <span class="meth">GetTopPlayerName</span>()
{
                <span class="kw">return</span> _scoreManager.<span class="meth">GetScores</span>()[<span class="lit">0</span>].<span class="prop">Name</span>;
}</code></pre>
                <p><code>_scoreManager</code> could be <code>null</code>, <code>GetScores()</code> could return <code>null</code>, or the array could contain a <code>null</code> reference at index 0. If any of those are <code>null</code>, it will crash. We need to check at each step:</p>
<pre><code class="language-csharp"><span class="kw">private</span> <span class="type">string</span>? <span class="meth">GetTopPlayerName</span>()
{
                <span class="kw">if</span> (_scoreManager == <span class="lit">null</span>) <span class="kw">return</span> <span class="lit">null</span>;
                <span class="type">Score</span>[]? scores = _scoreManager.<span class="meth">GetScores</span>();
                <span class="kw">if</span> (scores == <span class="lit">null</span>) <span class="kw">return</span> <span class="lit">null</span>;
                <span class="type">Score</span>? topScore = scores[<span class="lit">0</span>];
                <span class="kw">if</span> (topScore == <span class="lit">null</span>) <span class="kw">return</span> <span class="lit">null</span>;
                <span class="kw">return</span> topScore.<span class="prop">Name</span>;
}</code></pre>
                <p>...or using the null-conditional operators:</p>
<pre><code class="language-csharp"><span class="kw">private</span> <span class="type">string</span>? <span class="meth">GetTopPlayerName</span>()
{
                <span class="kw">return</span> _scoreManager<span class="sym">?.</span><span class="meth">GetScores</span>()<span class="sym">?[</span><span class="lit">0</span><span class="sym">]</span><span class="sym">?.</span><span class="prop">Name</span>;
}</code></pre>
                <p>Both <code>?.</code> and <code>?[]</code> evaluate the part before it to see if it is <code>null</code>. If it is, then no further evaluation happens, and the whole expression evaluates to <code>null</code>.</p>

                <h4>The Null Coalescing Operator: <code>??</code></h4>
                <p>The null coalescing operator (<code>??</code>) is also a useful tool. It takes an expression that might be <code>null</code> and provide a value or expression to use as a fallback if it is:</p>
<pre><code class="language-csharp"><span class="kw">private</span> <span class="type">string</span> <span class="meth">GetTopPlayerName</span>() <span class="comm">// No longer needs to allow nulls.</span>
{
                <span class="kw">return</span> _scoreManager<span class="sym">?.</span><span class="meth">GetScores</span>()<span class="sym">?[</span><span class="lit">0</span><span class="sym">]</span><span class="sym">?.</span><span class="prop">Name</span> <span class="sym">??</span> <span class="str">"(not found)"</span>;
}</code></pre>
                <p>There is also a compound assignment operator for this:</p>
<pre><code class="language-csharp"><span class="kw">private</span> <span class="type">string</span> <span class="meth">GetTopPlayerName</span>()
{
                <span class="type">string</span>? name = _scoreManager<span class="sym">?.</span><span class="meth">GetScores</span>()<span class="sym">?[</span><span class="lit">0</span><span class="sym">]</span><span class="sym">?.</span><span class="prop">Name</span>;
    name <span class="sym">??=</span> <span class="str">"(not found)"</span>;
                <span class="kw">return</span> name; <span class="comm">// No compiler warning. `??=` ensures we have a real value.</span>
}</code></pre>

                <h4>The Null-Forgiving Operator: <code>!</code></h4>
                <p><code>string message = MightReturnNullIfNegative(+10);</code> Assuming the return type of <code>MightReturnNullIfNegative</code> is <code>string?</code>, the compiler will flag this as a situation where you are assigning a potentially <code>null</code> value to a variable that indicates <code>null</code> isn’t allowed.</p>
                <p>...we can use the null-forgiving operator: <code>!</code>.</p>
                <p>This operator tells the compiler, “I know this looks like a potential <code>null</code> problem, but it won’t be. Trust me.”</p>
<pre><code class="language-csharp"><span class="type">string</span> message = <span class="meth">MightReturnNullIfNegative</span>(+<span class="lit">10</span>)<span class="sym">!</span>;</code></pre>

                <hr>

                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 23: OBJECT-ORIENTED DESIGN</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li><b>Object-oriented design</b> is figuring out which objects should exist in your program, which classes they belong to, what responsibilities each should have, and how they should work together.</li>
                    <li>The design starts with identifying the <b>requirements</b> of what you are building.</li>
                    <li><b>Noun extraction</b> helps get the design process started by identifying concepts and jobs to do in the requirements.</li>
                    <li><b>CRC cards</b> are a tool to think through a design with physical cards for each object, containing their class, responsibilities, and collaborators.</li>
                    <li>Object-oriented design is hard, but you don’t have to figure out the entire program all at once, nor do you have to get it right the first time.</li>
                </ul>

                <p>Object-oriented design is the part of crafting software where we decide:</p>
                <ul>
                    <li>which objects should exist in our program,</li>
                    <li>the classes each of those objects belong to,</li>
                    <li>what responsibilities each class or object should handle,</li>
                    <li>when objects should come into existence,</li>
                    <li>when objects should go out of existence,</li>
                    <li>which objects must collaborate with or rely upon which other objects,</li>
                    <li>and how an object knows about the other objects it works with.</li>
                </ul>

                <h3>REQUIREMENTS</h3>
                <p>The first step of building object-oriented systems is understanding what the software needs to do. This is sometimes called <b>requirements gathering</b>.</p>
                <p>Whether that is on paper, whiteboard, or digital document, the act of writing it out forces you to describe what you mean.</p>

                <h3>DESIGNING THE SOFTWARE</h3>
                <p>Find a system that works well for you.</p>

                <h4>Noun Extraction</h4>
                <p>You can start this process by highlighting the nouns (and noun phrases) and verbs (and verb phrases) that appear in the requirements.</p>

                <h4>CRC Cards</h4>
                <p><b>CRC cards</b> are a way to think through potential object-oriented designs and flesh out some detail. It helps you figure out which objects should exist, what parts of the overall problem each object should solve, and how they should work together.</p>

                <h4>Evaluating a Design</h4>
                <p><b>Rule #1: It has to work.</b> Look carefully at each design that you come up with. Does it do what it was supposed to do? If not, it isn’t a useful design.</p>
                <p><b>Rule #2: Prefer designs that convey meaning and intent.</b> Programmers spend more time reading code than writing it. When you come back and look at the classes, objects, and their interactions in two weeks or two years, which of the choices will be most understandable?</p>
                <p><b>Rule #3: Designs should not contain duplication.</b></p>
                <p><b>Rule #4: Designs should not have unused or unnecessary elements.</b></p>

                <h3>CREATING CODE</h3>
                <p>Remember: creating the actual code may give us more information, and we may realize that our initial pick was not ideal. When this happens, we should adapt and change our plan.</p>

                <h3>HOW TO COLLABORATE</h3>
                <p>Objects collaborate by calling members (methods, properties, etc.) on the object they need help from.</p>

                <h4>Creating New Objects</h4>
                <p>The first way to get a reference to an object is by creating a new instance with the <code>new</code> keyword.</p>

                <h4>Constructor Parameters</h4>
                <p>A second way is to have something else hand it the reference when the object is created as a constructor parameter. We could have passed the asteroids to the game through its constructor like this:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">AsteroidsGame</span>(<span class="type">Asteroid</span>[] startingAsteroids)
{
    _asteroids = startingAsteroids;
}</code></pre>

                <h4>Method Parameters</h4>
                <p>On the other hand, if an object only needs a reference to something for a single method, it can be passed in as a method parameter.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">AsteroidDriftingSystem</span>
{
                <span class="kw">public</span> <span class="type">void</span> <span class="meth">Update</span>(<span class="type">Asteroid</span>[] asteroids)
    {
                <span class="kw">foreach</span> (<span class="type">Asteroid</span> asteroid <span class="kw">in</span> asteroids)
        {
            asteroid.<span class="prop">PositionX</span> += asteroid.<span class="prop">VelocityX</span>;
            asteroid.<span class="prop">PositionY</span> += asteroid.<span class="prop">VelocityY</span>;
        }
    }
}</code></pre>

                <h4>Asking Another Object</h4>
                <p>An object can also get a reference to a collaborator by asking a third object to supply the reference.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">void</span> <span class="meth">Update</span>(<span class="type">AsteroidsGame</span> game)
{
                <span class="kw">foreach</span> (<span class="type">Asteroid</span> asteroid <span class="kw">in</span> game.<span class="prop">Asteroids</span>)
    {
        asteroid.<span class="prop">PositionX</span> += asteroid.<span class="prop">VelocityX</span>;
        asteroid.<span class="prop">PositionY</span> += asteroid.<span class="prop">VelocityY</span>;
    }
}</code></pre>

                <h4>Supplying the Reference via Property or Method</h4>
                <p>Suppose you can’t supply a reference to an object in the constructor but need it for more than one method.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">AsteroidDriftingSystem</span>
{
                <span class="comm">// Initialize this to an empty array, so we know it will never be null.</span>
                <span class="kw">public</span> <span class="type">Asteroid</span>[] <span class="prop">Asteroids</span> { <span class="kw">get</span>; <span class="kw">set</span>; } = <span class="kw">new</span> <span class="type">Asteroid</span>[<span class="lit">0</span>];
                <span class="kw">public</span> <span class="type">void</span> <span class="meth">Update</span>()
    {
                <span class="kw">foreach</span> (<span class="type">Asteroid</span> asteroid <span class="kw">in</span> <span class="prop">Asteroids</span>)
        {
            asteroid.<span class="prop">PositionX</span> += asteroid.<span class="prop">VelocityX</span>;
            asteroid.<span class="prop">PositionY</span> += asteroid.<span class="prop">VelocityY</span>;
        }
    }
}</code></pre>
                <p>Before this object’s <code>Update</code> method runs, the <code>AsteroidsGame</code> object must ensure this property has been set.</p>

                <h4>Static Members</h4>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">AsteroidsGame</span>
{
                <span class="kw">public</span> <span class="kw">static</span> <span class="type">AsteroidsGame</span> <span class="prop">Current</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="comm">// ...</span>
}</code></pre>
                <p>When the <code>main</code> method runs, it can assign a value to this:</p>
<pre><code class="language-csharp"><span class="type">AsteroidsGame</span>.<span class="prop">Current</span> = <span class="kw">new</span> <span class="type">AsteroidsGame</span>();
<span class="comm">// ...</span></code></pre>

                <h4>Choices, Choices</h4>
                <p>You can see that there are many options for building an interconnected network of objects— almost too many. But if we make the wrong choice, we can always go back and change it.</p>

                <h3>BABY STEPS</h3>
                <p>Just keep these things in mind:</p>
                <ul>
                    <li><b>You don’t have to get it right the first time.</b> It can always be changed. (Changing the structure of your code without changing what it does is called <b>refactoring</b>.)</li>
                    <li><b>You do not have to come up with a design to solve everything all at once.</b> Software is typically built a little at a time, making one or several closely related requirements work before moving on to the next. Following that model makes it so that no single design cycle is too scary.</li>
                    <li><b>Don’t be afraid to dive in and try stuff out.</b> Your first few attempts may be rough or ugly. But if you just start trying it and seeing what is working for you and what isn’t, your skills will grow quickly. (Don’t worry, the whole next level will get you more practice with this stuff.)</li>
                </ul>

                <hr>

                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 25: INHERITANCE</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li><b>Inheritance</b> lets you derive new classes based on existing ones. The new class inherits everything except constructors from the base class. <code><span class="kw">class</span> <span class="type">Derived</span> : <span class="type">Base</span> { ... }</code></li>
                    <li>Classes derive from <code>object</code> by default, and everything eventually derives from <code>object</code> even if another class is explicitly stated.</li>
                    <li>Constructors in a derived class must call out the constructor they are using from the base class unless they are using a parameterless constructor: <code><span class="kw">public</span> <span class="type">Derived</span>(<span class="kw">int</span> x) : <span class="kw">base</span>(x) { ...}</code></li>
                    <li>Derived class instances can be used where the base class is expected: <code><span class="type">Base</span> x = <span class="kw">new</span> <span class="type">Derived</span>();</code></li>
                    <li>The <code>protected</code> accessibility modifier makes things accessible in the class and any derived classes.</li>
                </ul>

                <p>Sometimes, a class is a <b>subtype</b> or <b>specialization</b> of another. The broader category has a set of capabilities that the subtype or specialization extends or enhances with more.</p>
                <p>Inheritance accomplishes two critical things. First, it allows you to treat the subtypes as the more generalized type whenever necessary. Second, it allows you to consolidate what would otherwise be duplicated or copy-and-pasted code in two closely related classes.</p>

                <p class="principle"><b>Object-Oriented Principle #4: Inheritance</b>—Basing one class on another, retaining the original class’s functionality while extending the new class with additional capabilities.</p>

                <h3>INHERITANCE AND THE OBJECT CLASS</h3>
                <p>...three things happen:</p>
                <ol>
                    <li>The new class gets everything the old class had,</li>
                    <li>the new class can add in extra stuff, and</li>
                    <li>the new class can always be treated as though it were the original since it has all of those capabilities.</li>
                </ol>
                <p>...everything is a specialization of the <code>object</code> class.</p>

                <h3>CHOOSING BASE CLASSES</h3>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">GameObject</span>
{
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">PositionX</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">PositionY</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">VelocityX</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">VelocityY</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="kw">void</span> <span class="meth">Update</span>()
    {
                <span class="prop">PositionX</span> += <span class="prop">VelocityX</span>;
                <span class="prop">PositionY</span> += <span class="prop">VelocityY</span>;
    }
}</code></pre>
                <p>We can now create an <code>Asteroid</code> class that includes things specific to just the asteroid and indicate that this class is derived from <code>GameObject</code> instead of plain <code>object</code>:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Asteroid</span> : <span class="type">GameObject</span>
{
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">Size</span> { <span class="kw">get</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">RotationAngle</span> { <span class="kw">get</span>; }
}</code></pre>
<pre><code class="language-csharp"><span class="type">GameObject</span>[] gameObjects = <span class="kw">new</span> <span class="type">GameObject</span>[]
{
                <span class="kw">new</span> <span class="type">Asteroid</span>(), <span class="kw">new</span> <span class="type">Asteroid</span>(), <span class="kw">new</span> <span class="type">Asteroid</span>(),
                <span class="kw">new</span> <span class="type">Bullet</span>(), <span class="kw">new</span> <span class="type">Ship</span>()
};</code></pre>
<pre><code class="language-csharp"><span class="kw">foreach</span> (<span class="type">GameObject</span> item <span class="kw">in</span> gameObjects)
    item.<span class="meth">Update</span>();</code></pre>
<pre><code class="language-csharp"><span class="type">Asteroid</span> asteroid = <span class="kw">new</span> <span class="type">GameObject</span>(); <span class="comm">// COMPILER ERROR!</span>
<span class="type">Ship</span> ship = <span class="kw">new</span> <span class="type">Asteroid</span>();       <span class="comm">// COMPILER ERROR!</span></code></pre>
                <p>A collection of classes related through inheritance, such as these four, is called an <b>inheritance hierarchy</b>.</p>

                <h3>CONSTRUCTORS</h3>
                <p>A derived class inherits most members from a base class but not constructors.</p>
                <p>If a parameterless constructor exists in the base class, a constructor in a derived class will automatically call it before running its own code.</p>
                <p>And remember: if a class does not define any constructor, the compiler will generate a simple, parameterless constructor.</p>
                <p>The same thing happens if you have manually made parameterless constructors:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">GameObject</span>
{
                <span class="kw">public</span> <span class="type">GameObject</span>()
    {
                <span class="prop">PositionX</span> = <span class="lit">2</span>;
                <span class="prop">PositionY</span> = <span class="lit">4</span>;
    }
                <span class="comm">// Properties and other things here.</span>
}</code></pre>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Asteroid</span> : <span class="type">GameObject</span>
{
                <span class="kw">public</span> <span class="type">Asteroid</span>()
    {
                <span class="prop">RotationAngle</span> = -<span class="lit">1</span>;
    }
                <span class="comm">// Properties and other things here.</span>
}</code></pre>
                <p>Here, <code>Asteroid</code>’s parameterless constructor will automatically call <code>GameObject</code>’s parameterless constructor. Calling <code>new Asteroid()</code> will enter <code>Asteroid</code>’s constructor and immediately jump to <code>GameObject</code>’s parameterless constructor to set <code>PositionX</code> and <code>PositionY</code> and then return to <code>Asteroid</code>’s constructor to set <code>RotationAngle</code>.</p>
                <p>Let’s suppose <code>GameObject</code> has only this constructor:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">GameObject</span>(<span class="type">float</span> positionX, <span class="type">float</span> positionY,
                <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)
{
                <span class="prop">PositionX</span> = positionX;
                <span class="prop">PositionY</span> = positionY;
                <span class="prop">VelocityX</span> = velocityX;
                <span class="prop">VelocityY</span> = velocityY;
}</code></pre>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">Asteroid</span>() : <span class="kw">base</span>(<span class="lit">0</span>, <span class="lit">0</span>, <span class="lit">0</span>, <span class="lit">0</span>)
{
}</code></pre>
                <p>It is relatively common to pass along parameters from the current constructor down to the base class’s constructor, so the following might be more common:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">Asteroid</span>(<span class="type">float</span> positionX, <span class="type">float</span> positionY,
                <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)
    : <span class="kw">base</span>(positionX, positionY, velocityX, velocityY)
{
}</code></pre>
                <p>...so let’s recap. Constructors are not inherited like other members are. Constructors in the derived class must call out a constructor from the base class (with <code>base</code>) to build upon. Alternatively, they can call out a different one in the same class (with <code>this</code>). If a parameterless constructor exists, including one the compiler generates, you do not need to state it explicitly with <code>base</code>. But don’t worry; the compiler will help you spot any problems.</p>

                <h3>THE PROTECTED ACCESS MODIFIER</h3>
                <p>We have encountered three accessibility modifiers in the past: <code>private</code>, <code>public</code>, and <code>internal</code>. The fourth accessibility modifier is the <code>protected</code> keyword.</p>
                <p>If something is <code>protected</code>, it is accessible within the class and also any derived classes.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">GameObject</span>
{
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">PositionX</span> { <span class="kw">get</span>; <span class="kw">protected</span> <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">PositionY</span> { <span class="kw">get</span>; <span class="kw">protected</span> <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">VelocityX</span> { <span class="kw">get</span>; <span class="kw">protected</span> <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">float</span> <span class="prop">VelocityY</span> { <span class="kw">get</span>; <span class="kw">protected</span> <span class="kw">set</span>; }
}</code></pre>
                <p>If we make these setters <code>protected</code> instead of <code>public</code>, only <code>GameObject</code> and its derived classes (like <code>Asteroid</code> and <code>Ship</code>) can change those properties; the outside world cannot.</p>

                <h3>SEALED CLASSES</h3>
                <p>If you want to forbid others from deriving from a specific class, you can prevent it by adding the <code>sealed</code> modifier.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">sealed</span> <span class="kw">class</span> <span class="type">Asteroid</span> : <span class="type">GameObject</span>
{
                <span class="comm">// ...</span>
}</code></pre>

                <hr>

                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 26: POLYMORPHISM</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li><b>Polymorphism</b> lets a derived class supply its own definition (“override”) for a member declared in its base class.</li>
                    <li>Marking a member with <code>virtual</code> indicates it can be overridden.</li>
                    <li>Derived classes override a member by marking it with <code>override</code>.</li>
                    <li>Classes can leave members unimplemented with <code>abstract</code>, but the class must also be <code>abstract</code>.</li>
                </ul>

                <p>Polymorphism allows us to solve this problem elegantly. Polymorphism means “many forms”.</p>

                <p class="principle"><b>Object-Oriented Principle #5: Polymorphism</b>—Derived classes can override methods from the base class. The correct version is determined at runtime, so you will get different behavior depending on the object’s class.</p>

<pre><code class="language-csharp"><span class="type">ChessPiece</span> p1 = <span class="kw">new</span> <span class="type">Pawn</span>();
<span class="type">ChessPiece</span> p2 = <span class="kw">new</span> <span class="type">King</span>();
<span class="type">Console</span>.<span class="meth">WriteLine</span>(p1.<span class="meth">IsLegalMove</span>(<span class="lit">2</span>, <span class="lit">2</span>));
<span class="type">Console</span>.<span class="meth">WriteLine</span>(p2.<span class="meth">IsLegalMove</span>(<span class="lit">2</span>, <span class="lit">2</span>));</code></pre>
                <p>Even though <code>p1</code> and <code>p2</code> both have the type <code>ChessPiece</code>, calling <code>IsLegalMove</code> will use the piece-specific version on the last two lines because of polymorphism.</p>
                <p>Not every method can leverage polymorphism. A method must indicate it is allowed by placing the <code>virtual</code> keyword on it, giving permission to derived classes to replace it.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">virtual</span> <span class="type">bool</span> <span class="meth">IsLegalMove</span>(<span class="type">int</span> row, <span class="type">int</span> column) =&gt;
                <span class="meth">IsOnBoard</span>(row, column) &&
    !<span class="meth">IsCurrentLocation</span>(row, column);</code></pre>
                <p>We can replace or <code>override</code> the method with an alternative version in a derived class.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">override</span> <span class="type">bool</span> <span class="meth">IsLegalMove</span>(<span class="type">int</span> row, <span class="type">int</span> column)
{
                <span class="kw">if</span> (!<span class="kw">base</span>.<span class="meth">IsLegalMove</span>(row, column)) <span class="kw">return</span> <span class="lit">false</span>;
                <span class="comm">// Moving more than one row or one column is not a legal king move.</span>
                <span class="kw">if</span> (<span class="type">Math</span>.<span class="meth">Abs</span>(row - <span class="prop">Row</span>) > <span class="lit">1</span>) <span class="kw">return</span> <span class="lit">false</span>;
                <span class="kw">if</span> (<span class="type">Math</span>.<span class="meth">Abs</span>(column - <span class="prop">Column</span>) > <span class="lit">1</span>) <span class="kw">return</span> <span class="lit">false</span>;
                <span class="kw">return</span> <span class="lit">true</span>;
}</code></pre>
                <p>If you want to reuse the overridden logic from the base class, you can call it through the <code>base</code> keyword.</p>
                <p>You can override most types of members except fields and constructors (which aren’t inherited anyway).</p>
                <p>Just because a method is <code>virtual</code> does not mean a derived class <i>must</i> override it.</p>
                <p>The overriding method must match the name and parameters (both count and type) as the overridden method. However, you can use a more specific type for the return value if you want.</p>
                <p>For example, if you have a <code>public virtual object Clone()</code> method, it can be overridden with a <code>public override SpecificClass Clone()</code> since <code>SpecificClass</code> is derived from <code>object</code>.</p>

                <h3>ABSTRACT METHODS AND CLASSES</h3>
                <p>Sometimes, a base class wants to require that all derived classes supply a definition for a method but can’t provide its own implementation. In such cases, it can define an <b>abstract method</b>, specifying the method’s signature without providing a body or implementation for the method.</p>
                <p>When a class has an <code>abstract</code> method, derived classes <i>must</i> override the method.</p>
                <p>You cannot create instances of it (only derived classes), and you must mark the class itself as <code>abstract</code> as well.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> <span class="type">ChessPiece</span>
{
                <span class="kw">public</span> <span class="kw">abstract</span> <span class="type">bool</span> <span class="meth">IsLegalMove</span>(<span class="type">int</span> targetRow, <span class="type">int</span> targetColumn);
                <span class="comm">// ...</span>
}</code></pre>
                <p>Adding the <code>abstract</code> keyword (instead of <code>virtual</code>) to a method says, “Not only <i>can</i> you override this method, but you <i>must</i> override this method.”</p>
                <p>...an <code>abstract</code> method ends with a semicolon.</p>
                <p>Abstract members can only live in abstract classes, but an abstract class can contain any member it wants—abstract, <code>virtual</code>, or normal.</p>

                <h3>NEW METHODS</h3>
                <p>If a derived class defines a member whose name matches something in a base class without overriding it, a new member will be created, which <b>hides</b> (instead of overrides) the base class.</p>
                <p>...you can tell the compiler it was intentional by adding the <code>new</code> keyword:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Base</span>
{
                <span class="kw">public</span> <span class="type">int</span> <span class="meth">Method</span>() =&gt; <span class="lit">0</span>;
}
<span class="kw">public</span> <span class="kw">class</span> <span class="type">Derived</span> : <span class="type">Base</span>
{
                <span class="kw">public</span> <span class="kw">new</span> <span class="type">int</span> <span class="meth">Method</span>() =&gt; <span class="lit">4</span>;
}</code></pre>
<pre><code class="language-csharp"><span class="type">Derived</span> d = <span class="kw">new</span> <span class="type">Derived</span>();
<span class="type">Base</span> b = d;
<span class="type">Console</span>.<span class="meth">WriteLine</span>(d.<span class="meth">Method</span>() + <span class="str">" "</span> + b.<span class="meth">Method</span>());</code></pre>
                <p>This displays <code>4 0</code>, not <code>4 4</code>.</p>



                <h1>Guía de Estudio — programación c# y .net</h1>
                <button onclick="descargarGuiaHTML()" class="download-btn">Descargar esta Guía</button>
                <p class="subtitle">Apuntes y conceptos clave extraídos del tema: 27-32 (salta el 31)</p>


                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 27: INTERFACES</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <p>An interface is a type that defines a contract or role that objects can fulfill or implement: <code><span class="kw">public</span> <span class="kw">interface</span> <span class="type">ILevelBuilder</span> { <span class="type">Level</span> <span class="meth">BuildLevel</span>(<span class="kw">int</span> levelNumber); }</code>.</p>
                <p>Classes can implement interfaces: <code><span class="kw">public</span> <span class="kw">class</span> <span class="type">LevelBuilder</span> : <span class="type">ILevelBuilder</span> { <span class="kw">public</span> <span class="type">Level</span> <span class="meth">BuildLevel</span>(<span class="kw">int</span> levelNumber) =&gt; <span class="kw">new</span> <span class="type">Level</span>(); }</code>.</p>
                <p>A class can have only one base class but can implement many interfaces.</p>
                <p>An interface is a type that defines an object’s interface or boundary by listing the methods, properties, etc., that an object must have without supplying any behavior for them.</p>
                <p>interface as defining a specific role or responsibility in the system without providing the code to make it happen.</p>

                <h3>DEFINING INTERFACES</h3>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">interface</span> <span class="type">ILevelBuilder</span>
{
                <span class="type">Level</span> <span class="meth">BuildLevel</span>(<span class="kw">int</span> levelNumber);
}</code></pre>
                <p>interface name with a capital I.</p>
                <p>Members of an interface are public and abstract automatically.</p>
                <p>...its members don’t have an implementation.</p>

                <h3>IMPLEMENTING INTERFACES</h3>
                <p>Once an interface has been created, the next step is to build a class that fulfills the job described by the interface. This is called implementing the interface.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">FixedLevelBuilder</span> : <span class="type">ILevelBuilder</span>
{
                <span class="kw">public</span> <span class="type">Level</span> <span class="meth">BuildLevel</span>(<span class="kw">int</span> levelNumber)
    {
                <span class="type">Level</span> level = <span class="kw">new</span> <span class="type">Level</span>(<span class="lit">10</span>, <span class="lit">10</span>, <span class="type">TerrainType</span>.<span class="prop">Forests</span>);
        level.<span class="meth">SetTerrainAt</span>(<span class="lit">2</span>, <span class="lit">4</span>, <span class="type">TerrainType</span>.<span class="prop">Mountains</span>);
        level.<span class="meth">SetTerrainAt</span>(<span class="lit">2</span>, <span class="lit">5</span>, <span class="type">TerrainType</span>.<span class="prop">Mountains</span>);
        level.<span class="meth">SetTerrainAt</span>(<span class="lit">6</span>, <span class="lit">1</span>, <span class="type">TerrainType</span>.<span class="prop">Desert</span>);
                <span class="kw">return</span> level;
    }
}</code></pre>
                <p>Like extending a base class through inheritance, you place a colon after the class name, followed by the interface name you are implementing.</p>
                <p>You must define each member included in the interface, as we did with the <code>BuildLevel</code> method. These will be public but do not put the <code>override</code> keyword on them. This isn’t an override. It is simply filling in the definition of how this class performs the job.</p>
                <p>A class that implements an interface can have other members unrelated to the interfaces it implements.</p>
                <p>...it will have at least the capabilities defined by the interface.</p>
                <p>...an interface can declare a property with a <code>get</code> accessor, while a class that implements it can also include a <code>set</code> or <code>init</code> accessor.</p>
<pre><code class="language-csharp"><span class="type">ILevelBuilder</span> levelBuilder = <span class="meth">LocateLevelBuilder</span>();
<span class="kw">int</span> currentLevel = <span class="lit">1</span>;

<span class="kw">while</span> (<span class="lit">true</span>)
{
                <span class="type">Level</span> level = levelBuilder.<span class="meth">BuildLevel</span>(currentLevel);
                <span class="meth">RunLevel</span>(level);
    currentLevel++;
}</code></pre>
                <p>...adding a new class that implements <code>ILevelBuilder</code> and changing the implementation of <code>LocateLevelBuilder</code> to return that instead, we can completely change the source of levels in our game.</p>
                <p>The entire rest of the game does not care where they come from.</p>
                <p>We have reserved a great degree of flexibility for the future by merely defining and using an interface.</p>

                <h3>INTERFACES AND BASE CLASSES</h3>
                <p>A class can simultaneously extend a base class and implement an interface.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">MySqlDatabaseLevelBuilder</span> : <span class="type">BasicDatabaseLevelBuilder</span>, <span class="type">ILevelBuilder</span> { ... }</code></pre>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">SomeClass</span> : <span class="type">ISomeInterface1</span>, <span class="type">ISomeInterface2</span> { ... }</code></pre>
                <p>...an interface itself can list other interfaces (but not classes) that it augments or extends.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">interface</span> <span class="type">IBroaderInterface</span> : <span class="type">INarrowerInterface</span> { ... }</code></pre>
                <p>When a class implements <code>IBroaderInterface</code>, they will also be on the hook to implement <code>INarrowerInterface</code>.</p>

                <h3>EXPLICIT INTERFACE IMPLEMENTATIONS</h3>
                <p>Occasionally, a class implements two different interfaces containing members with the same name but different meanings.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">interface</span> <span class="type">IBomb</span> { <span class="kw">void</span> <span class="meth">BlowUp</span>(); }
<span class="kw">public</span> <span class="kw">interface</span> <span class="type">IBalloon</span> { <span class="kw">void</span> <span class="meth">BlowUp</span>(); }
<span class="kw">public</span> <span class="kw">class</span> <span class="type">ExplodingBalloon</span> : <span class="type">IBomb</span>, <span class="type">IBalloon</span>
{
                <span class="kw">public</span> <span class="kw">void</span> <span class="meth">BlowUp</span>() { ... }
}</code></pre>
                <p>...in this situation, “blow up” means different things for bombs than it does balloons.</p>
                <p>We could rename <code>IBomb.BlowUp</code> to <code>Detonate</code> or <code>IBalloon.BlowUp</code> to <code>Inflate</code>. Problem solved. But if you don’t want to or can’t, the other choice is to make a definition for each using an explicit interface implementation:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">ExplodingBalloon</span> : <span class="type">IBomb</span>, <span class="type">IBalloon</span>
{
                <span class="kw">void</span> <span class="type">IBomb</span>.<span class="meth">BlowUp</span>() { <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"Kaboom!"</span>); }
                <span class="kw">void</span> <span class="type">IBalloon</span>.<span class="meth">BlowUp</span>() { <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"Whoosh"</span>); }
}</code></pre>
                <p>By prefacing the method name with the interface name, you can define two versions of <code>BlowUp</code>, one for each interface. Note that the <code>public</code> has been removed.</p>
                <p>The big surprise is that explicit implementations are detached from their containing class:</p>
<pre><code class="language-csharp"><span class="type">ExplodingBalloon</span> explodingBalloon = <span class="kw">new</span> <span class="type">ExplodingBalloon</span>();
<span class="comm">// explodingBalloon.BlowUp(); // COMPILER ERROR!</span>
<span class="type">IBomb</span> bomb = explodingBalloon;
bomb.<span class="meth">BlowUp</span>();
<span class="type">IBalloon</span> balloon = explodingBalloon;
balloon.<span class="meth">BlowUp</span>();</code></pre>
                <p>In this situation, you cannot call <code>BlowUp</code> directly on <code>ExplodingBalloon</code>! Instead, you must store it in a variable that is either <code>IBomb</code> or <code>IBalloon</code> (or cast it to one or the other). Then it becomes available because it is no longer ambiguous.</p>

                <h3>DEFAULT INTERFACE METHODS</h3>
                <p>If you want to add a new method or property to this interface, you have to revisit each of the ten implementations to adapt them to the new changes.</p>
                <p>If you can get an interface definition right the first time around, it saves you from this rework.</p>
                <p>...providing a default implementation for a method can be a decent alternative.</p>
                <p>...we might consider adding a <code>Level[] BuildAllLevels()</code> method to this interface.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">interface</span> <span class="type">ILevelBuilder</span>
{
                <span class="type">Level</span> <span class="meth">BuildLevel</span>(<span class="kw">int</span> levelNumber);
                <span class="kw">int</span> <span class="prop">Count</span> { <span class="kw">get</span>; }
                <span class="type">Level</span>[] <span class="meth">BuildAllLevels</span>();
}</code></pre>
                <p>...we can just make a default implementation for <code>BuildAllLevels</code>, nobody is required to make their own. We can grow the interface almost for free.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">interface</span> <span class="type">ILevelBuilder</span>
{
                <span class="type">Level</span> <span class="meth">BuildLevel</span>(<span class="kw">int</span> levelNumber);
                <span class="kw">int</span> <span class="prop">Count</span> { <span class="kw">get</span>; }
                <span class="type">Level</span>[] <span class="meth">BuildAllLevels</span>()
    {
                <span class="type">Level</span>[] levels = <span class="kw">new</span> <span class="type">Level</span>[<span class="prop">Count</span>];
                <span class="kw">for</span> (<span class="kw">int</span> index = <span class="lit">1</span>; index &lt;= <span class="prop">Count</span>; index++)
            levels[index - <span class="lit">1</span>] = <span class="meth">BuildLevel</span>(index);
                <span class="kw">return</span> levels;
    }
}</code></pre>
                <p>...nobody else will have to write a <code>BuildAllLevels</code> method unless they need something special.</p>
                <p>But if they do, it is a simple matter of adding a definition for the method in the class.</p>

                <h4>Should I Use Default Interface Methods?</h4>
                <p>My recommendation stems from the fact that interfaces are meant to define just the boundary, not the implementation. I suggest skipping default implementations except when many classes implement the interface and when the default implementation is nearly always correct for the classes that use the interface.</p>
                <p>Not every interface change can be solved with default method implementations.</p>

                <hr>


                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 28: STRUCTS</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li>A <code>struct</code> is a custom value type that defines a data structure without complex behavior: <code><span class="kw">public</span> <span class="kw">struct</span> <span class="type">Point</span> { ... }</code>. Structs are not focused on behavior but can have properties and methods.</li>
                    <li>Compared to classes: structs are value types, automatically have value semantics, and cannot be used in inheritance.</li>
                    <li>Make structs small, immutable, and ensure the default value is legitimate.</li>
                    <li>All the built-in types are aliases for other structs (and a few classes). For example, <code>int</code> is shorthand for <code>System.Int32</code>.</li>
                    <li>Value types can be stored in reference-typed variables (<code><span class="kw">object</span> thing = <span class="lit">3</span>;</code>) but will cause the value to be boxed and placed on the heap.</li>
                </ul>

                <p>C# also lets you make custom value types. New types of this nature are called <code>structs</code>.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">struct</span> <span class="type">Point</span>
{
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">X</span> { <span class="kw">get</span>; }
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">Y</span> { <span class="kw">get</span>; }
                <span class="kw">public</span> <span class="type">Point</span>(<span class="kw">float</span> x, <span class="kw">float</span> y)
    {
                <span class="prop">X</span> = x;
                <span class="prop">Y</span> = y;
    }
}</code></pre>
                <p>You can add fields, properties, methods, and constructors.</p>
                <p>The critical difference is that structs are value types instead of reference types.</p>
                <p>...a struct contain the data where the variable lives, instead of holding a reference that points to the data.</p>
                <p>Structs are primarily useful for representing small data-related concepts that don’t have a lot of behavior. Representing a 2D point.</p>

                <h3>MEMORY AND CONSTRUCTORS</h3>
                <p>First, while a constructor can be used to initialize data, invoking a constructor is not always necessary.</p>
                <p>Second, structs will always have a public parameterless constructor.</p>
                <p>...field initializers are a bit weird in a struct.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">struct</span> <span class="type">PairOfInts</span>
{
                <span class="kw">public</span> <span class="kw">int</span> <span class="prop">A</span> = <span class="lit">10</span>;
                <span class="kw">public</span> <span class="kw">int</span> <span class="prop">B</span> = -<span class="lit">2</span>;
}</code></pre>
                <p>These initializers do not always run.</p>
                <p>Field and property initializers don’t ever run if no constructor is called.</p>
                <p>The compiler-generated constructor runs these initializers only if the struct has no constructors.</p>
                <p>If you add your own constructors, these initializers will only run as a part of constructors you have defined, not as part of the compiler-generated one.</p>

                <h3>CLASSES VS. STRUCTS</h3>
                <p>...main difference is that classes are reference types and structs are value types.</p>
                <p>...structs cannot take on a <code>null</code> value.</p>
                <p>...structs are value types, reading and writing values to variables involves copying the whole pile of data around, not just a reference.</p>
                <p>...inheritance does not work well... so structs do not support it.</p>
                <p>Equality is also different for structs.</p>
                <p>...two things are equal if all of their data members are equal.</p>

                <h4>Choosing to Make a Class or a Struct</h4>
                <p>Structs are usually the better choice for small, data-focused types.</p>
                <p>...representing data and not doing work.</p>
                <p>...things like inheritance and polymorphism often are as well. You can’t get that from a struct.</p>
                <p>...struct’s methods are usually focused on answering questions about the data instead of getting work done.</p>
                <p>With a class, you can build a web of interconnected objects that know about each other through references. You can’t do the same thing with structs.</p>

                <h4>Rules to Follow When Making Structs</h4>
                <p>First, keep them small.</p>
                <p>Second, make structs immutable.</p>
                <p>...make its fields <code>readonly</code> and not have setters (not even private) for its properties. (An <code>init</code> accessor is fine.).</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">void</span> <span class="meth">ShiftLeft</span>(<span class="type">Point</span> p) =&gt; p.<span class="prop">X</span> -= <span class="lit">10</span>;</code></pre>
                <p>The variable <code>p</code>’s <code>X</code> property is shifted, but it is <code>ShiftLeft</code>’s copy. The original copy is unaffected. Making structs immutable sidesteps all sorts of bugs like this.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">Point</span> <span class="meth">ShiftLeft</span>(<span class="type">Point</span> p) =&gt; <span class="kw">new</span> <span class="type">Point</span>(p.<span class="prop">X</span> - <span class="lit">10</span>, p.<span class="prop">Y</span>);</code></pre>
                <p>Third, because struct values can exist without calling a constructor, a default, zeroed-out struct should represent a valid value.</p>

                <h3>BUILT-IN TYPE ALIASES</h3>
                <p>...<code>int</code> is an alias for <code>System.Int32</code>.</p>

                <h3>BOXING AND UNBOXING</h3>
<pre><code class="language-csharp"><span class="kw">object</span> thing = <span class="lit">3</span>;
<span class="kw">int</span> number = (<span class="kw">int</span>)thing;</code></pre>
                <p>...the data is pushed out to another location on the heap, in its own little container—a box. This is called a boxing conversion.</p>
                <p>After ensuring that the type is correct, the box’s contents are extracted—an unboxing conversion—and copied into the <code>number</code> variable.</p>

                <hr>


                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 29: RECORDS</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li>Records are a compact alternative notation for defining a data-centric class or struct: <code><span class="kw">public</span> <span class="kw">record</span> <span class="type">Point</span>(<span class="kw">float</span> X, <span class="kw">float</span> Y);</code>.</li>
                    <li>The compiler automatically generates a constructor, properties, <code>ToString</code>, equality with value semantics, and deconstruction.</li>
                    <li>You can add additional members or provide a definition for most compiler-synthesized members.</li>
                    <li>Records are turned into classes by default or into a struct (<code><span class="kw">public</span> <span class="kw">record</span> <span class="kw">struct</span> <span class="type">Point</span>(...)</code>).</li>
                    <li>Records can be used in a <code>with</code> expression: <code><span class="type">Point</span> modified = p <span class="kw">with</span> { <span class="prop">X</span> = -<span class="lit">2</span> };</code>.</li>
                </ul>

                <h3>RECORDS</h3>
                <p>C# has an ultra-compact way to define certain kinds of classes or structs.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="type">Point</span>(<span class="kw">float</span> X, <span class="kw">float</span> Y);
<span class="comm">// That's all.</span></code></pre>
                <p>The compiler will expand the above code into something like this:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Point</span>
{
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">X</span> { <span class="kw">get</span>; <span class="kw">init</span>; }
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">Y</span> { <span class="kw">get</span>; <span class="kw">init</span>; }
                <span class="kw">public</span> <span class="type">Point</span>(<span class="kw">float</span> x, <span class="kw">float</span> y)
    {
                <span class="prop">X</span> = x;
                <span class="prop">Y</span> = y;
    }
}</code></pre>

                <h4>String Representation</h4>
                <p>Records automatically override the <code>ToString</code>.</p>
                <p>...<code>new Point(2, 3).ToString()</code>...</p>
                <p><code>Point { X = 2, Y = 3 }</code></p>

                <h4>Value Semantics</h4>
                <p>...records automatically have value semantics.</p>
                <p>...<code>Equals</code> method, the <code>==</code> operator, and the <code>!=</code> operator are redefined to give it value semantics.</p>
<pre><code class="language-csharp"><span class="type">Point</span> a = <span class="kw">new</span> <span class="type">Point</span>(<span class="lit">2</span>, <span class="lit">3</span>);
<span class="type">Point</span> b = <span class="kw">new</span> <span class="type">Point</span>(<span class="lit">2</span>, <span class="lit">3</span>);
<span class="type">Console</span>.<span class="meth">WriteLine</span>(a == b);</code></pre>
                <p>Though <code>a</code> and <code>b</code> refer to different instances and use separate memory locations, this code displays <code>True</code> because the data are a perfect match, and the two are considered equal.</p>

                <h4>Deconstruction</h4>
<pre><code class="language-csharp"><span class="type">Point</span> p = <span class="kw">new</span> <span class="type">Point</span>(-<span class="lit">2</span>, <span class="lit">5</span>);
(<span class="kw">float</span> x, <span class="kw">float</span> y) = p;</code></pre>

                <h4>with Statements</h4>
                <p>...records are immutable by default, it is not uncommon to want a second copy.</p>
                <p>...records give you extra powers in the form of a <code>with</code> statement.</p>
<pre><code class="language-csharp"><span class="type">Point</span> p1 = <span class="kw">new</span> <span class="type">Point</span>(-<span class="lit">2</span>, <span class="lit">5</span>);
<span class="type">Point</span> p2 = p1 <span class="kw">with</span> { <span class="prop">X</span> = <span class="lit">0</span> };</code></pre>
                <p>You can replace many properties at once by separating them with commas: <code>Point p3 = p1 with { X = 0, Y = 0 };</code>.</p>

                <h3>ADVANCED SCENARIOS</h3>
                <p>You can add additional members and make your own definition to supplant most compiler-generated members.</p>

                <h4>Additional Members</h4>
                <p>The following shows a <code>Rectangle</code> record with <code>Width</code> and <code>Height</code> properties and then adds in an <code>Area</code> property, calculated from the rectangle’s width and height:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="type">Rectangle</span>(<span class="kw">float</span> Width, <span class="kw">float</span> Height)
{
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">Area</span> =&gt; <span class="prop">Width</span> * <span class="prop">Height</span>;
}</code></pre>

                <h4>Replacing Synthesized Members</h4>
                <p>While you can’t remove any of those features, you can customize most of them to meet your needs.</p>
                <p>...simply add in your own definition for <code>ToString</code>:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="type">Point</span>(<span class="kw">float</span> X, <span class="kw">float</span> Y)
{
                <span class="kw">public</span> <span class="kw">override</span> <span class="type">string</span> <span class="meth">ToString</span>() =&gt; $<span class="str">"({X}, {Y})"</span>;
}</code></pre>
                <p>...if it sees that you’ve provided a definition, it will use your version instead.</p>
                <p>One use for this is defining the properties as mutable properties or fields instead of the default init-only property.</p>
                <p>You’ll want to initialize them yourself:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="type">Point</span>(<span class="kw">float</span> X, <span class="kw">float</span> Y)
{
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">X</span> { <span class="kw">get</span>; <span class="kw">set</span>; } = X;
}</code></pre>

                <h4>Non-Positional Records</h4>
                <p>Most records will include a set of properties in parentheses after the record name. These are positional records... You could also write a simple record like this:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="type">Point</span>
{
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">X</span> { <span class="kw">get</span>; <span class="kw">init</span>; }
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">Y</span> { <span class="kw">get</span>; <span class="kw">init</span>; }
}</code></pre>
                <p>In this case, you wouldn’t get the constructor or the ability to do deconstruction (unless you add them in yourself).</p>

                <h3>STRUCT- AND CLASS-BASED RECORDS</h3>
                <p>The compiler turns records into classes by default.</p>
                <p>However, you can also make a record struct instead:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="kw">struct</span> <span class="type">Point</span>(<span class="kw">float</span> X, <span class="kw">float</span> Y);</code></pre>
                <p>...this is a value type instead of a reference type.</p>
                <p>A record struct creates properties slightly different.</p>
                <p>They are defined as <code>get</code>/<code>set</code> properties instead of <code>get</code>/<code>init</code>.</p>
                <p>The record struct above becomes something more like this:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">struct</span> <span class="type">Point</span>
{
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">X</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="kw">float</span> <span class="prop">Y</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
                <span class="kw">public</span> <span class="type">Point</span>(<span class="kw">float</span> x, <span class="kw">float</span> y)
    {
                <span class="prop">X</span> = x; <span class="prop">Y</span> = y;
    }
}</code></pre>
                <p>Whichever way you go, you can generally expect the same things of a record as you can of the class or struct it would become. For example, since you can make a class <code>abstract</code> or <code>sealed</code>, those are also options for class-based records.</p>

                <h4>Inheritance</h4>
                <p>Class-based records can also participate in inheritance with a few limitations. Records cannot derive from normal classes, and normal classes cannot derive from records.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">record</span> <span class="type">Point</span>(<span class="kw">float</span> X, <span class="kw">float</span> Y);
<span class="kw">public</span> <span class="kw">record</span> <span class="type">ColoredPoint</span>(<span class="type">Color</span> Color, <span class="kw">float</span> X, <span class="kw">float</span> Y) : <span class="type">Point</span>(X, Y);</code></pre>

                <h3>WHEN TO USE A RECORD</h3>
                <p>If the feature set of records fits your needs, you should generally prefer the record syntax.</p>
                <p>Records give you a concise way to make a type with several properties and a constructor to initialize them.</p>
                <p>They also give you a nice string representation, value semantics, deconstruction, and the ability to use <code>with</code> statements.</p>
                <p>If that suits your needs, a record is likely the right choice. If those features get in your way or are unhelpful, then a regular class or struct is the better choice.</p>
                <p>You should also consider records as a possible alternative to tuples.</p>

                <hr>


                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 30: GENERICS</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li>Generics solve the problem of making classes or methods that would differ only by the types they use. Generics leave placeholders for types that can be filled in when used.</li>
                    <li>Defining a generic class: <code><span class="kw">public</span> <span class="kw">class</span> <span class="type">List</span>&lt;T&gt; { <span class="kw">public</span> T <span class="meth">GetItemAt</span>(<span class="kw">int</span> index) {... } ... }</code>.</li>
                    <li>You can also make generic methods and generic types with multiple type parameters.</li>
                    <li>Constraints allow you to limit what can be used for a generic type argument while enabling you to know more about the types being used: <code><span class="kw">class</span> <span class="type">List</span>&lt;T&gt; <span class="kw">where</span> T : <span class="type">ISomeInterface</span> { }</code>.</li>
                </ul>

                <h3>THE MOTIVATION FOR GENERICS</h3>
                <p>...arrays have a big limitation: you can’t easily change their size by adding and removing items.</p>
                <p>The second approach would be just to use <code>object</code>.</p>
                <p>Neither of these solutions is perfect. But this is where generics save the day.</p>

                <h3>DEFINING A GENERIC TYPE</h3>
                <p>A generic type is a type definition (class, struct, or interface) that leaves a placeholder for some of the types it uses.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">List</span>&lt;T&gt;
{
                <span class="kw">private</span> T[] _items = <span class="kw">new</span> T[<span class="lit">0</span>];
                <span class="kw">public</span> T <span class="meth">GetItemAt</span>(<span class="kw">int</span> index) =&gt; _items[index];
                <span class="kw">public</span> <span class="kw">void</span> <span class="meth">SetItemAt</span>(<span class="kw">int</span> index, T <span class="kw">value</span>) =&gt; _items[index] = <span class="kw">value</span>;
                <span class="kw">public</span> <span class="kw">void</span> <span class="meth">Add</span>(T newValue)
    {
        T[] updated = <span class="kw">new</span> T[_items.<span class="prop">Length</span> + <span class="lit">1</span>];
                <span class="kw">for</span> (<span class="kw">int</span> index = <span class="lit">0</span>; index &lt; _items.<span class="prop">Length</span>; index++)
            updated[index] = _items[index];
        updated[^<span class="lit">1</span>] = newValue;
        _items = updated;
    }
}</code></pre>
                <p>When defining the class, we can identify a placeholder for a type in angle brackets (that <code>&lt;T&gt;</code> thing). This placeholder type is called a generic type parameter.</p>
                <p>It is like a method parameter, except it works at a higher level and stands in for a specific type that will be chosen later.</p>
                <p>It can be used throughout the class... When this <code>List&lt;T&gt;</code> class is used, that code will supply the specific type it needs instead of <code>T</code>.</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="kw">int</span>&gt; numbers = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="kw">int</span>&gt;();
numbers.<span class="meth">Add</span>(<span class="lit">1</span>);
numbers.<span class="meth">Add</span>(<span class="lit">2</span>);</code></pre>
                <p>In this case, <code>int</code> is used as the generic type argument... That means the <code>Add</code> method will have an <code>int</code> parameter, and <code>GetItemAt</code> will return an <code>int</code>.</p>
                <p>Without defining additional types, we can use a different type argument such as <code>string</code>:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt;();
words.<span class="meth">Add</span>(<span class="str">"Hello"</span>);
words.<span class="meth">Add</span>(<span class="str">"World"</span>);</code></pre>

                <h4>Multiple Generic Type Parameters</h4>
                <p>You can also have multiple generic type parameters by listing them in the angle brackets, separated by commas.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Pair</span>&lt;TFirst, TSecond&gt;
{
                <span class="kw">public</span> TFirst <span class="prop">First</span> { <span class="kw">get</span>; }
                <span class="kw">public</span> TSecond <span class="prop">Second</span> { <span class="kw">get</span>; }
                <span class="kw">public</span> <span class="type">Pair</span>(TFirst first, TSecond second)
    {
                <span class="prop">First</span> = first;
                <span class="prop">Second</span> = second;
    }
}</code></pre>
<pre><code class="language-csharp"><span class="type">Pair</span>&lt;<span class="type">string</span>, <span class="kw">double</span>&gt; namedNumber = <span class="kw">new</span> <span class="type">Pair</span>&lt;<span class="type">string</span>, <span class="kw">double</span>&gt;(<span class="str">"pi"</span>, <span class="lit">3.1415926535</span>);
<span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"{namedNumber.First} is {namedNumber.Second}"</span>);</code></pre>
                <p>...nested generic types with extremely long names: <code>Pair&lt;Pair&lt;int, int&gt;, double&gt;</code>.</p>
                <p>...complex names like this are why some people prefer <code>var</code> or <code>new()</code>.</p>

                <h4>Inheritance and Generic Types</h4>
                <p>A generic class can derive from normal non-generic classes or other generic classes, and normal classes can be derived from generic classes.</p>
                <p>The simplest thing is just to keep the generic type parameter open:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">FancyList</span>&lt;T&gt; : <span class="type">List</span>&lt;T&gt; { ... }</code></pre>
                <p>Or a derived class can close the generic type parameter, resulting in a derived class that is no longer generic:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">Polygon</span> : <span class="type">List</span>&lt;<span class="type">Point</span>&gt; { ... }</code></pre>
                <p>With this definition, <code>Polygon</code> is a subtype of <code>List&lt;Point&gt;</code>... The generic-ness is gone.</p>

                <h3>GENERIC METHODS</h3>
                <p>You can define generic methods by putting generic type parameters after a method’s name.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">static</span> <span class="type">List</span>&lt;T&gt; <span class="meth">Repeat</span>&lt;T&gt;(T <span class="kw">value</span>, <span class="kw">int</span> times)
{
                <span class="type">List</span>&lt;T&gt; collection = <span class="kw">new</span> <span class="type">List</span>&lt;T&gt;();
                <span class="kw">for</span> (<span class="kw">int</span> index = <span class="lit">0</span>; index &lt; times; index++)
        collection.<span class="meth">Add</span>(<span class="kw">value</span>);
                <span class="kw">return</span> collection;
}</code></pre>
                <p>You can use generic type parameters for method parameters and return types, as shown above. You can then use this like so:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="meth">Repeat</span>&lt;<span class="type">string</span>&gt;(<span class="str">"Alright"</span>, <span class="lit">3</span>);
<span class="type">List</span>&lt;<span class="kw">int</span>&gt; zeroes = <span class="meth">Repeat</span>&lt;<span class="kw">int</span>&gt;(<span class="lit">0</span>, <span class="lit">100</span>);</code></pre>
                <p>Generic methods do not have to live in a generic type.</p>
                <p>When using a generic method, the compiler can often infer the types... you can leave it out:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="meth">Repeat</span>(<span class="str">"Alright"</span>, <span class="lit">3</span>);</code></pre>
                <p>You usually only need to list the generic type argument when the compiler either can’t infer the type or is inferring the wrong type.</p>

                <h3>GENERIC TYPE CONSTRAINTS</h3>
                <p>If we give a generic type a constraint that it must be derived from <code>GameObject</code>, then we will know that it is safe to use any of the members <code>GameObject</code> defines:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">IDList</span>&lt;T&gt; <span class="kw">where</span> T : <span class="type">GameObject</span>
{
                <span class="kw">private</span> T[] items = <span class="kw">new</span> T[<span class="lit">0</span>];
                <span class="kw">public</span> T? <span class="meth">GetItemByID</span>(<span class="kw">int</span> idToFind)
    {
                <span class="kw">foreach</span> (T item <span class="kw">in</span> items)
                <span class="kw">if</span> (item.<span class="prop">ID</span> == idToFind)
                <span class="kw">return</span> item;
                <span class="kw">return</span> <span class="lit">null</span>;
    }
                <span class="kw">public</span> <span class="kw">void</span> <span class="meth">Add</span>(T newValue) { <span class="comm">/* ... */</span> }
}</code></pre>
                <p>That <code>where T : GameObject</code> is called a generic type constraint. It allows you to limit what type arguments can be used for the given type parameter.</p>
                <p><code>IDList</code> is still a generic type... But we can’t make an <code>IDList&lt;int&gt;</code> since <code>int</code> isn’t derived from <code>GameObject</code>.</p>
                <p>If you have several type parameters, you can constrain each of them with their own <code>where</code>:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">class</span> <span class="type">GenericType</span>&lt;T, U&gt; <span class="kw">where</span> T : <span class="type">GameObject</span>
                <span class="kw">where</span> U : <span class="type">Asteroid</span>
{ }</code></pre>
                <p>...<code>class?</code> constraint will assume usages of the generic type parameter allow <code>null</code> as an option.</p>
                <p>There is also a <code>new()</code> constraint (<code>where T : new()</code>), which limits you to using only types that have a parameterless constructor.</p>
                <p>You can also define constraints in relation to other generic type parameters... <code>public class Generic&lt;T, U&gt; where T : U { ... }</code>, or even <code>where T : IGenericInterface&lt;U&gt;</code>.</p>

                <h4>Multiple Constraints</h4>
                <p>...the following requires T to have a parameterless constructor and to be a <code>GameObject</code>: <code><span class="kw">public</span> <span class="kw">class</span> <span class="type">Factory</span>&lt;T&gt; <span class="kw">where</span> T : <span class="type">GameObject</span>, <span class="kw">new</span>() { ... }</code>.</p>
                <p>Not every constraint can be combined with every other constraint... For example, you can’t use both the <code>class</code> and <code>struct</code> constraints simultaneously.</p>
                <p>Also, you can’t combine the <code>struct</code> and <code>new()</code> constraints because the <code>struct</code> constraint already guarantees you have a public, parameterless constructor.</p>
                <p>The ordering of generic type constraints also matters.</p>

                <h3>THE DEFAULT OPERATOR</h3>
                <p>When using generic types, you may find some uses for the <code>default</code> operator, which allows you to get the default value for any type.</p>
                <p>...<code>default(int)</code> will evaluate to <code>0</code>, <code>default(bool)</code> will evaluate to <code>false</code>, and <code>default(string)</code> will evaluate to <code>null</code>.</p>
                <p>Where <code>default</code> shows its power is with generics. <code>default(T)</code> will produce the default, regardless of what type <code>T</code> is. If we go back to our <code>Pair&lt;TFirst, TSecond&gt;</code>, we could make a constructor that uses default values:</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="type">Pair</span>()
{
                <span class="prop">First</span> = <span class="kw">default</span>; <span class="comm">// Or default(TFirst), if the compiler cannot infer it.</span>
                <span class="prop">Second</span> = <span class="kw">default</span>; <span class="comm">// Or default(TSecond), if the compiler cannot infer it.</span>
}</code></pre>

                <hr>


                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 32: SOME USEFUL TYPES</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>


                <h3>Speedrun</h3>
                <ul>
                    <li><code>Random</code> generates pseudo-random numbers.</li>
                    <li><code>DateTime</code> gets the current time and stores time and date values.</li>
                    <li><code>TimeSpan</code> represents a length of time.</li>
                    <li><code>Guid</code> is used to store a globally unique identifier.</li>
                    <li><code>List&lt;T&gt;</code> is a popular and versatile generic collection—use it instead of arrays for most things.</li>
                    <li><code>IEnumerable&lt;T&gt;</code> is an interface for almost any collection type. The basis of <code>foreach</code> loops.</li>
                    <li><code>Dictionary&lt;TKey, TValue&gt;</code> can look up one piece of information from another.</li>
                    <li><code>Nullable&lt;T&gt;</code> is a struct that can express the concept of a missing value for value types.</li>
                    <li><code>ValueTuple</code> is the secret sauce behind tuples in C#.</li>
                    <li><code>StringBuilder</code> is a less memory-intensive way to build strings a little at a time.</li>
                </ul>

                <h3>THE RANDOM CLASS</h3>
                <p>The <code>Random</code> class (in the <code>System</code> namespace) generates random numbers.</p>
<pre><code class="language-csharp"><span class="type">Random</span> random = <span class="kw">new</span> <span class="type">Random</span>();
<span class="type">Console</span>.<span class="meth">WriteLine</span>(random.<span class="meth">Next</span>());</code></pre>
                <p><code>Next(int)</code> lets you pick the ceiling.</p>
                <p>...<code>random.Next(6)</code> will give you 0, 1, 2, 3, 4, or 5 (but not 6).</p>
<pre><code class="language-csharp"><span class="type">Console</span>.<span class="meth">WriteLine</span>(random.<span class="meth">Next</span>(<span class="lit">18</span>, <span class="lit">22</span>));</code></pre>
                <p>This will randomly pick from the values 18, 19, 20, and 21 (but not 22).</p>
<pre><code class="language-csharp"><span class="type">Console</span>.<span class="meth">WriteLine</span>(random.<span class="meth">NextDouble</span>());</code></pre>
                <p>This will give you a <code>double</code> in the range of 0.0 to 1.0. (Strictly speaking, 1.0 won’t ever come up, but 0.9999999 can.).</p>
                <p>And this will produce random numbers in the range -10 to +10:</p>
<pre><code class="language-csharp"><span class="type">Console</span>.<span class="meth">WriteLine</span>(random.<span class="meth">NextDouble</span>() * <span class="lit">20</span> - <span class="lit">10</span>);</code></pre>
                <p>The <code>Random</code> class also has a constructor that lets you pass in a specific seed:</p>
<pre><code class="language-csharp"><span class="type">Random</span> random = <span class="kw">new</span> <span class="type">Random</span>(<span class="lit">3445</span>);
<span class="type">Console</span>.<span class="meth">WriteLine</span>(random.<span class="meth">Next</span>());</code></pre>
                <p>This code will always display the same output because the seed is always 3445, which lets you recreate a random sequence of numbers.</p>

                <h3>THE DATETIME STRUCT</h3>
<pre><code class="language-csharp"><span class="type">DateTime</span> nowLocal = <span class="type">DateTime</span>.<span class="prop">Now</span>;
<span class="type">DateTime</span> nowUtc = <span class="type">DateTime</span>.<span class="prop">UtcNow</span>;</code></pre>
                <p><code>DateTime.Now</code> is in your local time zone... <code>DateTime.UtcNow</code> gives you the current time in Coordinated Universal Time or UTC.</p>
<pre><code class="language-csharp"><span class="type">DateTime</span> time = <span class="type">DateTime</span>.<span class="prop">Now</span>;
<span class="kw">if</span> (time.<span class="prop">Month</span> == <span class="lit">10</span>) <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"Happy Halloween!"</span>);
<span class="kw">else</span> <span class="kw">if</span> (time.<span class="prop">Month</span> == <span class="lit">4</span> && time.<span class="prop">Day</span> == <span class="lit">1</span>) <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"April Fools!"</span>);</code></pre>
                <p>There are also methods for getting new <code>DateTime</code> values relative to another. For example:</p>
<pre><code class="language-csharp"><span class="type">DateTime</span> tomorrow = <span class="type">DateTime</span>.<span class="prop">Now</span>.<span class="meth">AddDays</span>(<span class="lit">1</span>);</code></pre>

                <h3>THE TIMESPAN STRUCT</h3>
                <p>The <code>TimeSpan</code> struct (<code>System</code> namespace) represents a span of time.</p>
<pre><code class="language-csharp"><span class="type">TimeSpan</span> timeSpan1 = <span class="kw">new</span> <span class="type">TimeSpan</span>(<span class="lit">1</span>, <span class="lit">30</span>, <span class="lit">0</span>); <span class="comm">// 1 hour, 30 minutes, 0 seconds.</span>
<span class="type">TimeSpan</span> timeSpan2 = <span class="kw">new</span> <span class="type">TimeSpan</span>(<span class="lit">2</span>, <span class="lit">12</span>, <span class="lit">0</span>, <span class="lit">0</span>); <span class="comm">// 2 days, 12 hours.</span>
<span class="type">TimeSpan</span> timeSpan3 = <span class="kw">new</span> <span class="type">TimeSpan</span>(<span class="lit">0</span>, <span class="lit">0</span>, <span class="lit">0</span>, <span class="lit">0</span>, <span class="lit">500</span>); <span class="comm">// 500 milliseconds.</span>
<span class="type">TimeSpan</span> timeSpan4 = <span class="kw">new</span> <span class="type">TimeSpan</span>(<span class="lit">10</span>); <span class="comm">// 10 "ticks" == 1 microsecond</span></code></pre>
                <p>The other way to create <code>TimeSpans</code> is with one of the various <code>FromX</code> methods:</p>
<pre><code class="language-csharp"><span class="type">TimeSpan</span> aLittleWhile = <span class="type">TimeSpan</span>.<span class="meth">FromSeconds</span>(<span class="lit">3.5</span>);
<span class="type">TimeSpan</span> quiteAWhile = <span class="type">TimeSpan</span>.<span class="meth">FromHours</span>(<span class="lit">1.21</span>);</code></pre>
                <p>These represent the various components of the <code>TimeSpan</code>.</p>
<pre><code class="language-csharp"><span class="type">TimeSpan</span> timeLeft = <span class="kw">new</span> <span class="type">TimeSpan</span>(<span class="lit">1</span>, <span class="lit">30</span>, <span class="lit">0</span>);
<span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"{timeLeft.Days}d {timeLeft.Hours}h {timeLeft.Minutes}m"</span>);</code></pre>
<pre><code class="language-csharp"><span class="type">TimeSpan</span> timeRemaining = <span class="kw">new</span> <span class="type">TimeSpan</span>(<span class="lit">1</span>, <span class="lit">30</span>, <span class="lit">0</span>);
<span class="type">Console</span>.<span class="meth">WriteLine</span>(timeRemaining.<span class="prop">TotalHours</span>);
<span class="type">Console</span>.<span class="meth">WriteLine</span>(timeRemaining.<span class="prop">TotalMinutes</span>);</code></pre>
                <p>This will display: <code>1.5</code> <code>90</code></p>
                <p>...comparison (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>), addition, and subtraction.</p>
<pre><code class="language-csharp"><span class="type">DateTime</span> eventTime = <span class="kw">new</span> <span class="type">DateTime</span>(<span class="lit">2022</span>, <span class="lit">12</span>, <span class="lit">4</span>, <span class="lit">5</span>, <span class="lit">29</span>, <span class="lit">0</span>); <span class="comm">// 4 Dec 2022 at 5:29am</span>
<span class="type">TimeSpan</span> timeLeft = eventTime - <span class="type">DateTime</span>.<span class="prop">Now</span>;</code></pre>
<pre><code class="language-csharp"><span class="comm">// 'TimeSpan.Zero' is no time at all.</span>
<span class="kw">if</span> (timeLeft > <span class="type">TimeSpan</span>.<span class="prop">Zero</span>)
                <span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"{timeLeft.Days}d {timeLeft.Hours}h {timeLeft.Minutes}m"</span>);
<span class="kw">else</span>
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"This event has passed."</span>);</code></pre>

                <h3>THE GUID STRUCT</h3>
                <p>The <code>Guid</code> struct (<code>System</code> namespace) represents a globally unique identifier or GUID.</p>
<pre><code class="language-csharp"><span class="type">Guid</span> id = <span class="type">Guid</span>.<span class="meth">NewGuid</span>();</code></pre>
                <p>Each <code>Guid</code> value is 16 bytes (4 times as many as an <code>int</code>).</p>
                <p>A <code>Guid</code> is just a collection of 16 bytes, but it is usually written in hexadecimal with dashes breaking it into smaller chunks like this: <code>10A24EC2-3008-4678-AD86-FCCCDA8CE868</code>.</p>
                <p>If you already have a GUID and do not want to generate a new one, there are other constructors... For example:</p>
<pre><code class="language-csharp"><span class="type">Guid</span> id = <span class="kw">new</span> <span class="type">Guid</span>(<span class="str">"10A24EC2-3008-4678-AD86-FCCCDA8CE868"</span>);</code></pre>

                <h3>THE LIST&lt;T&gt; CLASS</h3>
                <p><code>List&lt;T&gt;</code> is a collection class where order matters, you can access items by their index, and where items can be added and removed easily.</p>
                <p>...grow and shrink makes them superior.</p>

                <h4>Creating List Instances</h4>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="kw">int</span>&gt; numbers = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="kw">int</span>&gt;();</code></pre>
                <p>...you can also use collection initializer.</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="kw">int</span>&gt; numbers = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="kw">int</span>&gt;() { <span class="lit">1</span>, <span class="lit">2</span>, <span class="lit">3</span> };</code></pre>

                <h4>Indexing</h4>
                <p>Lists support indexing.</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt;() { <span class="str">"apple"</span>, <span class="str">"banana"</span>, <span class="str">"corn"</span>, <span class="str">"durian"</span> };
<span class="type">Console</span>.<span class="meth">WriteLine</span>(words[<span class="lit">2</span>]);</code></pre>
                <p>You can replace an item in a list.</p>
<pre><code class="language-csharp">words[<span class="lit">0</span>] = <span class="str">"avocado"</span>;</code></pre>

                <h4>Adding and Removing Items from List</h4>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt;();
words.<span class="meth">Add</span>(<span class="str">"apple"</span>);</code></pre>
                <p><code>Add</code> puts items at the back of the list. To put something in the middle, you use <code>Insert</code>, which requires an index and the item:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt;() { <span class="str">"apple"</span>, <span class="str">"banana"</span>, <span class="str">"durian"</span> };
words.<span class="meth">Insert</span>(<span class="lit">2</span>, <span class="str">"corn"</span>);</code></pre>
                <p>...add or insert many items, there is <code>AddRange</code> and <code>InsertRange</code>:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt;();
words.<span class="meth">AddRange</span>(<span class="kw">new</span> <span class="type">string</span>[] { <span class="str">"apple"</span>, <span class="str">"durian"</span> });
words.<span class="meth">InsertRange</span>(<span class="lit">1</span>, <span class="kw">new</span> <span class="type">string</span>[] { <span class="str">"banana"</span>, <span class="str">"corn"</span> });</code></pre>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt;() { <span class="str">"apple"</span>, <span class="str">"banana"</span>, <span class="str">"corn"</span>, <span class="str">"durian"</span> };
words.<span class="meth">Remove</span>(<span class="str">"banana"</span>);</code></pre>
                <p>If an item is in the collection more than once, only the first occurrence is removed.</p>
                <p><code>Remove</code> returns a <code>bool</code> that tells you whether anything was removed... If you want to remove the item at a specific index, use <code>RemoveAt</code>: <code>words.RemoveAt(0);</code> The <code>Clear</code> method removes everything in the list: <code>words.Clear();</code>.</p>
                <p>...list has a <code>Count</code> property: <code>Console.WriteLine(words.Count);</code>.</p>

                <h4>foreach Loops</h4>
                <p>You can use a <code>foreach</code> loop with a <code>List&lt;T&gt;</code>.</p>
<pre><code class="language-csharp"><span class="kw">foreach</span> (<span class="type">Ship</span> ship <span class="kw">in</span> ships)
    ship.<span class="meth">Update</span>();</code></pre>
                <p>But there’s a crucial catch: you cannot add or remove items in a <code>List&lt;T&gt;</code> while a <code>foreach</code> is in progress.</p>
                <p>There are two workarounds for this. One is to use a plain <code>for</code> loop.</p>
<pre><code class="language-csharp"><span class="kw">for</span> (<span class="kw">int</span> index = <span class="lit">0</span>; index &lt; ships.<span class="prop">Count</span>; index++)
{
                <span class="type">Ship</span> ship = ships[index];
    ship.<span class="meth">Update</span>();
                <span class="kw">if</span> (ship.<span class="prop">IsDead</span>)
    {
        ships.<span class="meth">Remove</span>(ship);
        index--;
    }
}</code></pre>
                <p>Another workaround is to hold off on the actual addition or removal... place them in helper lists like <code>toBeAdded</code> and <code>toBeRemoved</code>. After the <code>foreach</code> loop, go through the items in those two helper lists...</p>

                <h4>Other Useful Things</h4>
                <p>The <code>Contains</code> method tells you if the list contains a specific item, returning a <code>bool</code>.</p>
                <p>The <code>IndexOf</code> method tells you where in a list an item can be found, or -1 if it is not there: <code>int index = words.IndexOf("apple");</code>.</p>

                <h3>THE IENUMERABLE&lt;T&gt; INTERFACE</h3>
                <p><code>IEnumerable&lt;T&gt;</code> is anything that can provide an “enumerator”.</p>
<pre><code class="language-csharp"><span class="kw">public</span> <span class="kw">interface</span> <span class="type">IEnumerable</span>&lt;T&gt;
{
                <span class="type">IEnumerator</span>&lt;T&gt; <span class="meth">GetEnumerator</span>();
}</code></pre>
                <p>The <code>Current</code> property lets you see the current item. The <code>MoveNext</code> method advances to the next item and returns whether there even is another item... Almost nobody uses an <code>IEnumerator&lt;T&gt;</code> directly. They let the <code>foreach</code> loop deal with it. Consider this code:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt; { <span class="str">"apple"</span>, <span class="str">"banana"</span>, <span class="str">"corn"</span>, <span class="str">"durian"</span> };
<span class="kw">foreach</span>(<span class="type">string</span> word <span class="kw">in</span> words)
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(word);</code></pre>
                <p>That is equivalent to this:</p>
<pre><code class="language-csharp"><span class="type">List</span>&lt;<span class="type">string</span>&gt; words = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="type">string</span>&gt; { <span class="str">"apple"</span>, <span class="str">"banana"</span>, <span class="str">"corn"</span>, <span class="str">"durian"</span> };
<span class="type">IEnumerator</span>&lt;<span class="type">string</span>&gt; iterator = words.<span class="meth">GetEnumerator</span>();

<span class="kw">while</span> (iterator.<span class="meth">MoveNext</span>())
{
                <span class="type">string</span> word = iterator.<span class="prop">Current</span>;
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(word);
}</code></pre>

                <h3>THE DICTIONARY&lt;TKEY, TVALUE&gt; CLASS</h3>
                <p>You add new items to the dictionary by supplying a key to store the item under, and when you want to retrieve it, you provide the key again to get the item back out.</p>
                <p>If we wanted to make an English language dictionary in C# code:</p>
<pre><code class="language-csharp"><span class="type">Dictionary</span>&lt;<span class="type">string</span>, <span class="type">string</span>&gt; dictionary = <span class="kw">new</span> <span class="type">Dictionary</span>&lt;<span class="type">string</span>, <span class="type">string</span>&gt;();</code></pre>
                <p>We can add items to the dictionary using the indexing operator with the key instead of an <code>int</code>:</p>
<pre><code class="language-csharp">dictionary[<span class="str">"battleship"</span>] = <span class="str">"a large warship with big guns"</span>;
dictionary[<span class="str">"cruiser"</span>] = <span class="str">"a fast but large warship"</span>;
dictionary[<span class="str">"submarine"</span>] = <span class="str">"a ship capable of moving under the water's surface"</span>;</code></pre>
                <p>To retrieve a value, you can also use the indexing operator:</p>
<pre><code class="language-csharp"><span class="type">Console</span>.<span class="meth">WriteLine</span>(dictionary[<span class="str">"battleship"</span>]);</code></pre>
                <p>If you reuse a key, the new value replaces the first:</p>
<pre><code class="language-csharp">dictionary[<span class="str">"carrier"</span>] = <span class="str">"a ship that carries stuff"</span>;
dictionary[<span class="str">"carrier"</span>] = <span class="str">"a ship that serves as a floating runway for aircraft"</span>;
<span class="type">Console</span>.<span class="meth">WriteLine</span>(dictionary[<span class="str">"carrier"</span>]);</code></pre>
                <p>This displays the second, longer definition; the first is gone.</p>
                <p>What if you try to retrieve the item with a key that isn’t in the dictionary? <code>Console.WriteLine(dictionary["gunship"]);</code></p>
                <p>...it throws a <code>KeyNotFoundException</code>.</p>
<pre><code class="language-csharp"><span class="kw">if</span> (dictionary.<span class="meth">ContainsKey</span>(<span class="str">"gunship"</span>))
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(dictionary[<span class="str">"gunship"</span>]);</code></pre>
                <p>Or we could ask it to use a fallback value with the <code>GetValueOrDefault</code> method:</p>
<pre><code class="language-csharp"><span class="type">Console</span>.<span class="meth">WriteLine</span>(dictionary.<span class="meth">GetValueOrDefault</span>(<span class="str">"gunship"</span>, <span class="str">"unknown"</span>));</code></pre>
                <p>If you want to remove a key and its value:</p>
<pre><code class="language-csharp">dictionary.<span class="meth">Remove</span>(<span class="str">"battleship"</span>);</code></pre>
                <p>This returns a <code>bool</code> that indicates if anything was removed.</p>

                <h4>Types Besides string</h4>
                <p>...we might create a <code>WordDefinition</code> class... and then use that in a dictionary: <code>var dictionary = new Dictionary&lt;string, WordDefinition&gt;();</code>.</p>
                <p>Or perhaps we have a collection of <code>GameObject</code> instances... and each instance has an ID that is an <code>int</code>.</p>
<pre><code class="language-csharp"><span class="type">Dictionary</span>&lt;<span class="kw">int</span>, <span class="type">GameObject</span>&gt; gameObjects = <span class="kw">new</span> <span class="type">Dictionary</span>&lt;<span class="kw">int</span>, <span class="type">GameObject</span>&gt;();</code></pre>

                <h4>Dictionary Keys Should Not Change</h4>
                <p>Dictionaries use the hash code of the key to store and locate the object in memory. A hash code is a special value determined by each object, as returned by <code>GetHashCode()</code>.</p>

                <h3>THE NULLABLE&lt;T&gt; STRUCT</h3>
                <p>The <code>Nullable&lt;T&gt;</code> struct (<code>System</code> namespace) lets you pretend that a value type can take on a <code>null</code> value.</p>
                <p>It does this by attaching a <code>bool HasValue</code> property to the original value.</p>
<pre><code class="language-csharp"><span class="type">Nullable</span>&lt;<span class="kw">int</span>&gt; maybeNumber = <span class="kw">new</span> <span class="type">Nullable</span>&lt;<span class="kw">int</span>&gt;(<span class="lit">3</span>);
<span class="type">Nullable</span>&lt;<span class="kw">int</span>&gt; another = <span class="kw">new</span> <span class="type">Nullable</span>&lt;<span class="kw">int</span>&gt;();</code></pre>
<pre><code class="language-csharp"><span class="kw">if</span> (maybeNumber.<span class="prop">HasValue</span>)
                <span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"The number is {maybeNumber.Value}."</span>);
<span class="kw">else</span>
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"The number is missing."</span>);</code></pre>
                <p>...most C# programmers will use the following instead:</p>
<pre><code class="language-csharp"><span class="kw">int</span>? maybeNumber = <span class="lit">3</span>;
<span class="kw">int</span>? another = <span class="lit">null</span>;</code></pre>
                <p><code>int?</code> is the same as <code>Nullable&lt;int&gt;</code>, and even <code>int</code> itself is simply the <code>Int32</code> struct.</p>

                <h3>VALUETUPLE STRUCTS</h3>
<pre><code class="language-csharp">(<span class="type">string</span>, <span class="kw">int</span>, <span class="kw">int</span>) score = (<span class="str">"R2-D2"</span>, <span class="lit">12420</span>, <span class="lit">15</span>);</code></pre>
                <p>That is a shorthand version of this:</p>
<pre><code class="language-csharp"><span class="type">ValueTuple</span>&lt;<span class="type">string</span>, <span class="kw">int</span>, <span class="kw">int</span>&gt; score = <span class="kw">new</span> <span class="type">ValueTuple</span>&lt;<span class="type">string</span>, <span class="kw">int</span>, <span class="kw">int</span>&gt;(<span class="str">"R2-D2"</span>, <span class="lit">12420</span>, <span class="lit">15</span>);</code></pre>

                <h3>THE STRINGBUILDER CLASS</h3>
<pre><code class="language-csharp"><span class="type">System.Text.StringBuilder</span> text = <span class="kw">new</span> <span class="type">System.Text.StringBuilder</span>();
<span class="kw">while</span> (<span class="lit">true</span>)
{
                <span class="type">string</span>? input = <span class="type">Console</span>.<span class="meth">ReadLine</span>();
                <span class="kw">if</span> (input == <span class="lit">null</span> || input == <span class="str">""</span>) <span class="kw">break</span>;
    text.<span class="meth">Append</span>(input);
    text.<span class="meth">Append</span>(<span class="str">' '</span>);
}
<span class="type">Console</span>.<span class="meth">WriteLine</span>(text.<span class="meth">ToString</span>());</code></pre>
                <p><code>StringBuilder</code> is an optimization to use when necessary... if you are doing anything intensive, <code>StringBuilder</code> may be an easy substitute to help keep memory usage in check.</p>


                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>
        <!-- Nuevos capítulos 33-37 -->
        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 33: MANAGING LARGER PROGRAMS</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>

                <h3>Speedrun</h3>
                <ul>
                    <li>C# programs can be spread across multiple files. It is common to put each type in its own file.</li>
                    <li>Namespaces are a way to organize type definitions into named groups. Types intended for reuse should be placed in a namespace.</li>
                    <li>A <code>using</code> directive allows you to use the simple name for a type instead of its fully qualified name.</li>
                    <li>Several namespaces, including <code>System</code>, are automatically included in .NET 6+ projects and need no <code>using</code> directive. You can add to this list with a global <code>using</code> directive.</li>
                    <li>A <code>using static</code> directive allows you to use static members of a type without the type name.</li>
                    <li>Add types to a namespace with either <code><span class="kw">namespace</span> Name { ... }</code> or by putting <code><span class="kw">namespace</span> Name;</code> at the start of a file.</li>
                    <li>Traditional entry points (before .NET 5) declare a <code><span class="kw">public static void</span> <span class="meth">Main</span>(<span class="kw">string</span>[] args)</code> method in a <code>Program</code> class.</li>
                </ul>

                <h3>Using Multiple Files</h3>
                <p>As your programs grow, having everything in a single file becomes unwieldy. Most C# programmers prefer putting types into separate files with a name that matches the type name.</p>
                <pre><code class="language-csharp"><span class="kw">public class</span> <span class="type">One</span> { }</code></pre>
                <p>You can use shortcuts like <b>Alt + Enter</b> to access Quick Actions to move a type to its own file (e.g., <code>One.cs</code>). Many C# programmers put each type in separate files; you're in good company if you do the same. Note that a program can only contain one file with a main method.</p>

                <h3>Namespaces and Using Directives</h3>
                <p>Namespaces help organize code and prevent naming collisions.</p>
                <ul>
                    <li><b>System:</b> Contains foundational types like <code>Console</code>, <code>Convert</code>, built-in types, <code>Math</code>, <code>Random</code>, <code>DateTime</code>, etc.</li>
                    <li><b>System.Collections.Generic:</b> Contains generic collections like <code>List&lt;T&gt;</code>, <code>IEnumerable&lt;T&gt;</code>, and <code>Dictionary&lt;TKey, TValue&gt;</code>.</li>
                </ul>
                <p>A <code>using</code> directive tells the compiler to look in a specific namespace for types:</p>
                <pre><code class="language-csharp"><span class="kw">using</span> <span class="type">System.Text</span>;</code></pre>
                <p>With that directive, you no longer need the fully qualified name. Starting with C# 10, several directives are implicitly added (like <code>System</code>, <code>System.Collections.Generic</code>, <code>System.Linq</code>, etc.).</p>

                <h4>Advanced Using Directive Features</h4>
                <p><b>Global using directives:</b> Include the <code>global</code> keyword to make a directive apply to all files in the project.</p>
                <pre><code class="language-csharp"><span class="kw">global using</span> <span class="type">SomeNamespace</span>;</code></pre>
                <p>It is recommended to put these in a separate file like <code>GlobalUsings.cs</code>.</p>

                <p><b>Static using directives:</b> Allow access to static members without typing the class name.</p>
                <pre><code class="language-csharp"><span class="kw">using static</span> <span class="type">System.Math</span>;
<span class="kw">using static</span> <span class="type">System.Console</span>;</code></pre>

                <p><b>Name Conflicts and Aliases:</b> If two types share a name, you can use an alias to resolve the conflict.</p>
                <pre><code class="language-csharp"><span class="kw">using</span> <span class="type">PhysicsPoint</span> = <span class="type">PhysicsEngine.Point</span>;
<span class="kw">using</span> <span class="type">UIPoint</span> = <span class="type">UserInterface.Point</span>;

<span class="type">PhysicsPoint</span> p1 = <span class="kw">new</span> <span class="type">PhysicsPoint</span>();
<span class="type">UIPoint</span> p2 = <span class="kw">new</span> <span class="type">UIPoint</span>();</code></pre>

                <h3>Putting Types into Namespaces</h3>
                <p>Anything meant to be shared should be in a namespace. Use the <code>namespace</code> keyword.</p>
                <pre><code class="language-csharp"><span class="kw">namespace</span> <span class="type">SpaceGame</span>
{
                <span class="kw">public enum</span> <span class="type">Color</span> { Red, Green, Blue, Yellow }
                <span class="kw">public class</span> <span class="type">Point</span> { <span class="comm">/* ... */</span> }
}</code></pre>
                <p>Namespaces can be nested (e.g., <code>SpaceGame.Drawing</code>). A file-scoped namespace declaration eliminates indentation:</p>
                <pre><code class="language-csharp"><span class="kw">namespace</span> <span class="type">SpaceGame</span>;
<span class="kw">public enum</span> <span class="type">Color</span> { Red, Green, Blue, Yellow }
<span class="kw">public class</span> <span class="type">Point</span> { <span class="comm">/* ... */</span> }</code></pre>
                <p><b>Conventions:</b> If your project is named <code>SpaceGame</code>, your root namespace should be <code>SpaceGame</code>. Folders usually correspond to nested namespaces (e.g., a folder named <code>Graphics</code> implies <code>SpaceGame.Graphics</code>).</p>

                <h3>Traditional Entry Points</h3>
                <p>Before top-level statements, the entry point was explicitly defined:</p>
                <pre><code class="language-csharp"><span class="kw">using</span> <span class="type">System</span>;
<span class="kw">namespace</span> <span class="type">HelloWorld</span>
{
                <span class="kw">internal class</span> <span class="type">Program</span>
    {
                <span class="kw">static void</span> <span class="meth">Main</span>(<span class="kw">string</span>[] args)
        {
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"Hello, World!"</span>);
        }
    }
}</code></pre>

                <hr>
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 34: METHODS REVISITED</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>

                <h3>Speedrun</h3>
                <ul>
                    <li>A parameter can be given a default value, making it optional: <code><span class="kw">void</span> <span class="meth">DoStuff</span>(<span class="kw">int</span> x = <span class="lit">4</span>)</code>.</li>
                    <li>You can use named arguments: <code><span class="meth">DoStuff</span>(x: <span class="lit">2</span>)</code>. This allows changing order.</li>
                    <li><code>params</code> allows a variable number of arguments: <code><span class="kw">void</span> <span class="meth">DoStuff</span>(<span class="kw">params string</span>[] words)</code>.</li>
                    <li>Use <code>ref</code> or <code>out</code> to pass by reference. <code>out</code> is for when the method initializes the variable.</li>
                    <li>A <code>Deconstruct</code> method allows unpacking objects into variables: <code>(<span class="kw">float</span> x, <span class="kw">float</span> y) = point;</code>.</li>
                    <li>Extension methods appear as methods of another type: <code><span class="kw">static string</span> <span class="meth">Extension</span>(<span class="kw">this string</span> text)</code>.</li>
                </ul>

                <h3>Optional and Named Arguments</h3>
                <p>Define a default value in the method signature. Optional parameters must come last. You cannot use <code>new List&lt;int&gt;()</code> as a default (must be a compile-time constant).</p>
                <pre><code class="language-csharp"><span class="kw">public int</span> <span class="meth">RollDie</span>(<span class="kw">int</span> sides = <span class="lit">6</span>) => _random.<span class="meth">Next</span>(sides) + <span class="lit">1</span>;</code></pre>
                <p>Named arguments allow clarity and out-of-order execution:</p>
                <pre><code class="language-csharp"><span class="type">Math</span>.<span class="meth">Clamp</span>(min: <span class="lit">50</span>, max: <span class="lit">100</span>, value: <span class="lit">20</span>);</code></pre>

                <h3>Variable Number of Parameters</h3>
                <p>Use the <code>params</code> keyword to accept an array of arguments as a comma-separated list.</p>
                <pre><code class="language-csharp"><span class="kw">public static double</span> <span class="meth">Average</span>(<span class="kw">params int</span>[] numbers)
{
                <span class="kw">double</span> total = <span class="lit">0</span>;
                <span class="kw">foreach</span> (<span class="kw">int</span> number <span class="kw">in</span> numbers)
        total += number;
                <span class="kw">return</span> total / numbers.Length;
}

<span class="meth">Average</span>(<span class="lit">2</span>, <span class="lit">3</span>);
<span class="meth">Average</span>(<span class="lit">2</span>, <span class="lit">5</span>, <span class="lit">8</span>);
<span class="meth">Average</span>(<span class="lit">41</span>, <span class="lit">49</span>, <span class="lit">29</span>, <span class="lit">2</span>, <span class="lit">-7</span>, <span class="lit">18</span>);</code></pre>

                <h3>Passing by Reference</h3>
                <p>Normally, values are copied (pass by value). Passing by reference shares the memory location. Useful for large structs or modifying variables.</p>

                <h4>ref Parameter</h4>
                <p>Must be initialized before calling. Use <code>ref</code> in definition and call.</p>
                <pre><code class="language-csharp"><span class="kw">void</span> <span class="meth">Swap</span>(<span class="kw">ref int</span> a, <span class="kw">ref int</span> b)
{
                <span class="kw">int</span> temporary = a;
    a = b;
    b = temporary;
}
<span class="kw">int</span> y = <span class="lit">3</span>;
<span class="meth">DisplayNumber</span>(<span class="kw">ref</span> y);</code></pre>

                <h4>out Parameter</h4>
                <p>Similar to <code>ref</code>, but does not require initialization before calling. The method <i>must</i> assign a value before returning.</p>
                <pre><code class="language-csharp"><span class="kw">void</span> <span class="meth">SetupNumber</span>(<span class="kw">bool</span> useBigNumber, <span class="kw">out double</span> value)
{
    value = useBigNumber ? <span class="lit">1000000</span> : <span class="lit">1</span>;
}

<span class="meth">SetupNumber</span>(<span class="kw">true</span>, <span class="kw">out double</span> x);
<span class="meth">SetupNumber</span>(<span class="kw">false</span>, <span class="kw">out double</span> y);</code></pre>

                <h3>Deconstructors</h3>
                <p>Enable unpacking objects into variables (like tuples). Define a method named <code>Deconstruct</code> with <code>out</code> parameters.</p>
                <pre><code class="language-csharp"><span class="kw">var</span> tuple = (<span class="lit">2</span>, <span class="lit">3</span>);
(<span class="kw">int</span> a, <span class="kw">int</span> b) = tuple;

<span class="kw">public void</span> <span class="meth">Deconstruct</span>(<span class="kw">out float</span> x, <span class="kw">out float</span> y)
{
    x = X;
    y = Y;
}</code></pre>

                <h3>Extension Methods</h3>
                <p>Allow adding methods to existing types (even if you don't own the code). Must be a <code>static</code> method in a <code>static</code> class. Use <code>this</code> before the first parameter.</p>
                <pre><code class="language-csharp"><span class="kw">public static class</span> <span class="type">StringExtensions</span>
{
                <span class="kw">public static string</span> <span class="meth">ToAlternating</span>(<span class="kw">this string</span> text)
    {
                <span class="kw">string</span> result = <span class="str">""</span>;
                <span class="kw">bool</span> isCapital = <span class="kw">true</span>;
                <span class="kw">foreach</span> (<span class="kw">char</span> letter <span class="kw">in</span> text)
        {
            result += isCapital ? <span class="kw">char</span>.<span class="meth">ToUpper</span>(letter) : <span class="kw">char</span>.<span class="meth">ToLower</span>(letter);
            isCapital = !isCapital;
        }
                <span class="kw">return</span> result;
    }
}

<span class="kw">string</span> message = <span class="str">"Hello, World!"</span>;
<span class="type">Console</span>.<span class="meth">WriteLine</span>(message.<span class="meth">ToAlternating</span>());</code></pre>

                <hr>
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 35: ERROR HANDLING AND EXCEPTIONS</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>

                <h3>Speedrun</h3>
                <ul>
                    <li>Exceptions are the primary error handling mechanism. They are objects of type <code>Exception</code>.</li>
                    <li>Use <code>try</code> blocks for code that might fail, and <code>catch</code> blocks to handle errors.</li>
                    <li>Throw exceptions with <code>throw new Exception();</code>.</li>
                    <li>A <code>finally</code> block runs regardless of the outcome (success or exception).</li>
                </ul>

                <h3>Handling Exceptions</h3>
                <p>Exceptions bubble up the call stack. Catching them prevents a crash.</p>
                <pre><code class="language-csharp"><span class="kw">try</span>
{
    number = <span class="type">Convert</span>.<span class="meth">ToInt32</span>(response);
}
<span class="kw">catch</span> (<span class="type">FormatException</span>)
{
    number = <span class="lit">-1</span>;
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"I do not understand."</span>);
}
<span class="kw">catch</span> (<span class="type">OverflowException</span>)
{
    number = <span class="lit">-1</span>;
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"Number too big!"</span>);
}
<span class="kw">catch</span> (<span class="type">Exception</span> e) <span class="comm">// Catch-all</span>
{
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(e.Message);
}</code></pre>

                <h3>Throwing Exceptions</h3>
                <p>Use specific exception types when possible (e.g., <code>ArgumentNullException</code>, <code>InvalidOperationException</code>).</p>
                <pre><code class="language-csharp"><span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"Name an animal."</span>);
<span class="kw">string</span>? animal = <span class="type">Console</span>.<span class="meth">ReadLine</span>();
<span class="kw">if</span> (animal == <span class="str">"snake"</span>) <span class="kw">throw new</span> <span class="type">NotSupportedException</span>(<span class="str">"I have ophidiophobia."</span>);</code></pre>

                <h3>The Finally Block</h3>
                <p>Code in <code>finally</code> runs whether the <code>try</code> block succeeds, fails, or returns early. Useful for cleanup.</p>
                <pre><code class="language-csharp"><span class="kw">try</span>
{
                <span class="comm">// Potentially failing code</span>
}
<span class="kw">catch</span> (<span class="type">SnakeException</span>) { <span class="comm">/* Handle error */</span> }
<span class="kw">finally</span>
{
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"We're all done here."</span>);
}</code></pre>

                <h3>Exception Guidelines</h3>
                <ul>
                    <li><b>Only Handle What You Can Fix:</b> If you can't resolve it, let it bubble up.</li>
                    <li><b>Use the Right Exception Type:</b> Avoid generic <code>Exception</code> if a specific one fits.</li>
                    <li><b>Avoid Pokémon Exception Handling:</b> Don't catch everything (<code>catch (Exception)</code>) unless necessary (e.g., global logging).</li>
                    <li><b>Avoid Eating Exceptions:</b> Empty catch blocks (<code>catch { }</code>) hide bugs.</li>
                    <li><b>Avoid Throwing When Possible:</b> Use logic (<code>if</code>) instead of exceptions for predictable control flow.</li>
                </ul>

                <h3>Advanced Handling</h3>
                <p><b>Stack Traces:</b> <code>Console.WriteLine(e)</code> prints the exception and the stack trace (where it happened).</p>
                <p><b>Rethrowing:</b> Use <code>throw;</code> inside a catch block to preserve the original stack trace. Using <code>throw e;</code> resets the trace.</p>
                <p><b>Exception Filters:</b> Use <code>when</code> to conditionally catch an exception.</p>
                <pre><code class="language-csharp"><span class="kw">catch</span> (<span class="type">CodedErrorException</span> e) <span class="kw">when</span> (e.ErrorCode == <span class="type">ErrorCodes</span>.ConnectionFailure) { ... }</code></pre>

                <hr>
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 36: DELEGATES</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>

                <h3>Speedrun</h3>
                <ul>
                    <li>A delegate is a variable that stores methods, allowing them to be passed like objects.</li>
                    <li>Define: <code><span class="kw">public delegate float</span> <span class="type">NumberDelegate</span>(<span class="kw">float</span> number);</code>.</li>
                    <li>Assign: <code><span class="type">NumberDelegate</span> d = <span class="meth">AddOne</span>;</code>.</li>
                    <li>Invoke: <code>d(<span class="lit">2</span>)</code> or <code>d.<span class="meth">Invoke</span>(<span class="lit">2</span>)</code>.</li>
                    <li><code>Action</code>, <code>Func</code>, and <code>Predicate</code> are pre-defined generic delegates.</li>
                </ul>

                <h3>Delegate Basics</h3>
                <p>Delegates allow methods to be passed as parameters to other methods, increasing flexibility.</p>
                <pre><code class="language-csharp"><span class="kw">using</span> <span class="type">System</span>;

<span class="kw">namespace</span> <span class="type">DelegadosDemo</span>
{
                <span class="comm">// 1. DEFINICIÓN DEL DELEGADO (El Contrato)</span>
                <span class="comm">// Define que cualquier método que queramos usar debe recibir un int y devolver un int.</span>
                <span class="kw">public delegate int</span> <span class="type">NumberDelegate</span>(<span class="kw">int</span> number);

                <span class="kw">class</span> <span class="type">Program</span>
    {
                <span class="kw">static void</span> <span class="meth">Main</span>(<span class="kw">string</span>[] args)
        {
                <span class="comm">// Datos de prueba</span>
                <span class="kw">int</span>[] numerosOriginales = { <span class="lit">1</span>, <span class="lit">2</span>, <span class="lit">3</span>, <span class="lit">4</span>, <span class="lit">5</span> };

                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"--- PRUEBA 1: Usando AddOne ---"</span>);
                <span class="comm">// Pasamos el método 'AddOne' como parámetro. No ponemos paréntesis () porque no lo ejecutamos aquí.</span>
                <span class="kw">int</span>[] resultadoSuma = <span class="meth">ChangeArrayElements</span>(numerosOriginales, <span class="meth">AddOne</span>);
                <span class="meth">ImprimirArray</span>(resultadoSuma);


                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"\n--- PRUEBA 2: Usando ElevarAlCuadrado ---"</span>);
                <span class="comm">// Reutilizamos LA MISMA función 'ChangeArrayElements', pero cambiamos la lógica inyectada.</span>
                <span class="kw">int</span>[] resultadoCuadrado = <span class="meth">ChangeArrayElements</span>(numerosOriginales, <span class="meth">ElevarAlCuadrado</span>);
                <span class="meth">ImprimirArray</span>(resultadoCuadrado);
        }

                <span class="comm">// 2. EL MÉTODO PROCESADOR (El que recibe el delegado)</span>
                <span class="comm">// Este método sabe recorrer un array, pero NO sabe qué hacer con los números.</span>
                <span class="comm">// Delega esa responsabilidad al parámetro 'operation'.</span>
                <span class="kw">static int</span>[] <span class="meth">ChangeArrayElements</span>(<span class="kw">int</span>[] numbers, <span class="type">NumberDelegate</span> operation)
        {
                <span class="kw">int</span>[] result = <span class="kw">new</span> <span class="kw">int</span>[numbers.Length];
            
                <span class="kw">for</span> (<span class="kw">int</span> index = <span class="lit">0</span>; index < result.Length; index++)
            {
                <span class="comm">// Aquí ocurre la magia: Ejecutamos la función que nos hayan pasado</span>
                result[index] = operation(numbers[index]); 
            }
            
                <span class="kw">return</span> result;
        }

                <span class="comm">// 3. LAS IMPLEMENTACIONES (Las funciones que cumplen el contrato)</span>
        
                <span class="comm">// Opción A: Sumar 1 (Cumple con recibir int y devolver int)</span>
                <span class="kw">static int</span> <span class="meth">AddOne</span>(<span class="kw">int</span> number)
        {
                <span class="kw">return</span> number + <span class="lit">1</span>;
        }

                <span class="comm">// Opción B: Elevar al cuadrado (También cumple el contrato)</span>
                <span class="kw">static int</span> <span class="meth">ElevarAlCuadrado</span>(<span class="kw">int</span> number)
        {
                <span class="kw">return</span> number * number;
        }

                <span class="comm">// Método auxiliar solo para mostrar los resultados en consola</span>
                <span class="kw">static void</span> <span class="meth">ImprimirArray</span>(<span class="kw">int</span>[] array)
        {
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="kw">string</span>.<span class="meth">Join</span>(<span class="str">", "</span>, array));
        }
    }
}</code></pre>

                <h3>Action, Func, and Predicate</h3>
                <p>You rarely need to define custom delegates thanks to these generic types:</p>
                <ul>
                    <li><b>Action:</b> Returns <code>void</code>. Can have parameters. E.g., <code>Action&lt;string&gt;</code> matches <code>void Method(string s)</code>.</li>
                    <li><b>Func:</b> Returns a value. Last generic parameter is the return type. E.g., <code>Func&lt;int, double&gt;</code> matches <code>double Method(int i)</code>.</li>
                    <li><b>Predicate:</b> Returns <code>bool</code>. E.g., <code>Predicate&lt;T&gt;</code> is equivalent to <code>Func&lt;T, bool&gt;</code>.</li>
                </ul>

                <pre><code class="language-csharp"><span class="kw">using</span> <span class="type">System</span>;
<span class="kw">using</span> <span class="type">System.Collections.Generic</span>;

<span class="kw">public class</span> <span class="type">Program</span>
{
                <span class="kw">public static void</span> <span class="meth">Main</span>()
    {
                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"--- 1. ACTION (Void) ---"</span>);
                <span class="comm">// ACTION: Siempre devuelve void.</span>
                <span class="comm">// Sintaxis: Action&lt;TipoParametro1, TipoParametro2, ...&gt;</span>
        
                <span class="comm">// Ejemplo: Recibe un string, imprime en consola. No devuelve nada.</span>
                <span class="type">Action</span>&lt;<span class="kw">string</span>&gt; logger = (mensaje) => 
        {
                <span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"[LOG]: {mensaje}"</span>);
        };

                <span class="comm">// Uso</span>
        logger(<span class="str">"Iniciando sistema..."</span>);
        logger(<span class="str">"Carga completada."</span>);


                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"\n--- 2. FUNC (Retorna Valor) ---"</span>);
                <span class="comm">// FUNC: Siempre devuelve un valor.</span>
                <span class="comm">// Sintaxis: Func&lt;Input1, Input2, ..., TIPO_RETORNO&gt;</span>
                <span class="comm">// IMPORTANTE: El último parámetro genérico es SIEMPRE el tipo que devuelve.</span>

                <span class="comm">// Ejemplo: Recibe dos enteros (int, int) y devuelve un entero (int)</span>
                <span class="type">Func</span>&lt;<span class="kw">int</span>, <span class="kw">int</span>, <span class="kw">int</span>&gt; multiplicar = (x, y) => 
        {
                <span class="kw">return</span> x * y;
        };

                <span class="comm">// Uso</span>
                <span class="kw">int</span> resultado = multiplicar(<span class="lit">5</span>, <span class="lit">4</span>);
                <span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"El resultado de 5 * 4 es: {resultado}"</span>);


                <span class="type">Console</span>.<span class="meth">WriteLine</span>(<span class="str">"\n--- 3. PREDICATE (Retorna Bool) ---"</span>);
                <span class="comm">// PREDICATE: Siempre recibe un dato y devuelve true/false.</span>
                <span class="comm">// Sintaxis: Predicate&lt;TipoEntrada&gt;</span>
                <span class="comm">// Es equivalente a escribir: Func&lt;TipoEntrada, bool&gt;</span>

                <span class="comm">// Ejemplo: Recibe un número y verifica si es par.</span>
                <span class="type">Predicate</span>&lt;<span class="kw">int</span>&gt; esPar = (numero) => 
        {
                <span class="kw">return</span> numero % <span class="lit">2</span> == <span class="lit">0</span>;
        };

                <span class="comm">// Uso</span>
                <span class="kw">int</span> numeroPrueba = <span class="lit">10</span>;
                <span class="kw">bool</span> check = esPar(numeroPrueba);
                <span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"¿El número {numeroPrueba} es par? {check}"</span>);
        
        
                <span class="comm">// Ejemplo práctico: Usando Predicate en una lista real</span>
                <span class="type">List</span>&lt;<span class="kw">int</span>&gt; listaNumeros = <span class="kw">new</span> <span class="type">List</span>&lt;<span class="kw">int</span>&gt; { <span class="lit">1</span>, <span class="lit">3</span>, <span class="lit">5</span>, <span class="lit">8</span>, <span class="lit">10</span> };
                <span class="comm">// Find usa un Predicate internamente</span>
                <span class="kw">int</span> primerPar = listaNumeros.<span class="meth">Find</span>(esPar); 
                <span class="type">Console</span>.<span class="meth">WriteLine</span>($<span class="str">"Primer par encontrado en la lista: {primerPar}"</span>);
    }
}</code></pre>

                <h3>Multicast Delegates</h3>
                <p>Delegates can hold multiple methods (a chain). Use <code>+=</code> to add and <code>-=</code> to remove methods. Invoking the delegate calls all methods in the chain.</p>
                <pre><code class="language-csharp"><span class="type">Log</span> logMethods = <span class="meth">LogToConsole</span>;
logMethods += <span class="meth">LogToDatabase</span>;
logMethods += <span class="meth">LogToTextFile</span>;</code></pre>

                <hr>
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-header" onclick="toggleChapter(this)">LEVEL 37: EVENTS</div>
            <div class="chapter-content">
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>

                <h3>Speedrun</h3>
                <ul>
                    <li>Events allow a class to notify interested observers that something occurred.</li>
                    <li>Definition: <code><span class="kw">public event</span> <span class="type">Action</span> ThingHappened;</code>.</li>
                    <li>Raise event: <code><span class="meth">ThingHappened</span>();</code> or <code>ThingHappened?.<span class="meth">Invoke</span>();</code>.</li>
                    <li>Subscribe/Unsubscribe: <code>obj.ThingHappened += <span class="meth">Handler</span>;</code> and <code>obj.ThingHappened -= <span class="meth">Handler</span>;</code>.</li>
                    <li>Unsubscribing is important to avoid memory leaks.</li>
                </ul>

                <h3>Defining and Raising Events</h3>
                <p>Events allow an object to broadcast notifications without knowing who is listening.</p>
                <pre><code class="language-csharp"><span class="kw">public class</span> <span class="type">Ship</span>
{
                <span class="kw">public event</span> <span class="type">Action</span>? ShipExploded; <span class="comm">// Defined with a delegate type</span>

                <span class="kw">public void</span> <span class="meth">TakeDamage</span>(<span class="kw">int</span> amount)
    {
        Health -= amount;
                <span class="kw">if</span> (Health <= <span class="lit">0</span>)
                <span class="meth">ShipExploded</span>?.<span class="meth">Invoke</span>(); <span class="comm">// Raising the event safely</span>
    }
}</code></pre>

                <h3>Subscribing to Events</h3>
                <p>Listeners attach methods (handlers) to the event.</p>
                <pre><code class="language-csharp"><span class="kw">public class</span> <span class="type">SoundEffectManager</span>
{
                <span class="kw">public</span> <span class="meth">SoundEffectManager</span>(<span class="type">Ship</span> ship)
    {
        ship.ShipExploded += <span class="meth">OnShipExploded</span>; <span class="comm">// Subscribe</span>
    }
    
                <span class="kw">private void</span> <span class="meth">OnShipExploded</span>() => <span class="meth">PlaySound</span>(<span class="str">"Explosion"</span>);
}</code></pre>

                <h3>EventHandler</h3>
                <p>Standard pattern using <code>EventHandler</code> and <code>EventArgs</code>.</p>
                <pre><code class="language-csharp"><span class="kw">public class</span> <span class="type">ExplosionEventArgs</span> : <span class="type">EventArgs</span>
{
                <span class="kw">public</span> <span class="type">Point</span> Location { <span class="kw">get</span>; }
                <span class="kw">public</span> <span class="meth">ExplosionEventArgs</span>(<span class="type">Point</span> location) => Location = location;
}

<span class="kw">public event</span> <span class="type">EventHandler</span>&lt;<span class="type">ExplosionEventArgs</span>&gt;? ShipExploded;</code></pre>
                <p>Raising it:</p>
                <pre><code class="language-csharp">ShipExploded?.<span class="meth">Invoke</span>(<span class="kw">this</span>, <span class="kw">new</span> <span class="type">ExplosionEventArgs</span>(Location));</code></pre>

                <h3>Custom Event Accessors</h3>
                <p>Like properties, events can have custom <code>add</code> and <code>remove</code> blocks.</p>
                <pre><code class="language-csharp"><span class="kw">private</span> <span class="type">Action</span>? _shipExploded;
<span class="kw">public event</span> <span class="type">Action</span> ShipExploded
{
                <span class="kw">add</span> { _shipExploded += <span class="kw">value</span>; }
                <span class="kw">remove</span> { _shipExploded -= <span class="kw">value</span>; }
}</code></pre>

                <hr>
                <button class="close-btn" onclick="toggleChapter(this)">Cerrar</button>
            </div>
        </div>

    </div>
    <script>
        function toggleChapter(el){
            let chapter = el.closest('.chapter');
            let content = chapter.querySelector('.chapter-content');
            if(content.style.display === 'block'){
                content.style.display = 'none';
            } else {
                content.style.display = 'block';
                content.scrollIntoView({behavior: 'smooth', block: 'start'});
            }
        }
    </script>
</body>
</html>
